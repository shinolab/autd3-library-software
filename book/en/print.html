<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AUTD3 Developers Manual v1.11.1.0</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Software/index.html"><strong aria-hidden="true">1.</strong> Software</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Software/about_AUTD3.html"><strong aria-hidden="true">1.1.</strong> About AUTD3</a></li><li class="chapter-item expanded "><a href="Software/Users_Manual/index.html"><strong aria-hidden="true">1.2.</strong> C++ User's Manual</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Software/Users_Manual/concept.html"><strong aria-hidden="true">1.2.1.</strong> Concept</a></li><li class="chapter-item expanded "><a href="Software/Users_Manual/getting_started.html"><strong aria-hidden="true">1.2.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="Software/Users_Manual/geometry.html"><strong aria-hidden="true">1.2.3.</strong> Geometry</a></li><li class="chapter-item expanded "><a href="Software/Users_Manual/link.html"><strong aria-hidden="true">1.2.4.</strong> Link</a></li><li class="chapter-item expanded "><a href="Software/Users_Manual/gain.html"><strong aria-hidden="true">1.2.5.</strong> Gain</a></li><li class="chapter-item expanded "><a href="Software/Users_Manual/modulation.html"><strong aria-hidden="true">1.2.6.</strong> Modulation</a></li><li class="chapter-item expanded "><a href="Software/Users_Manual/stm.html"><strong aria-hidden="true">1.2.7.</strong> Spatio-Temporal Modulation</a></li><li class="chapter-item expanded "><a href="Software/Users_Manual/controller.html"><strong aria-hidden="true">1.2.8.</strong> Controller</a></li></ol></li><li class="chapter-item expanded "><a href="Software/FFI/index.html"><strong aria-hidden="true">1.3.</strong> FFI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Software/FFI/csharp.html"><strong aria-hidden="true">1.3.1.</strong> C#</a></li><li class="chapter-item expanded "><a href="Software/FFI/python.html"><strong aria-hidden="true">1.3.2.</strong> python</a></li><li class="chapter-item expanded "><a href="Software/FFI/julia.html"><strong aria-hidden="true">1.3.3.</strong> Julia</a></li><li class="chapter-item expanded "><a href="Software/FFI/rust.html"><strong aria-hidden="true">1.3.4.</strong> Rust</a></li><li class="chapter-item expanded "><a href="Software/FFI/reference.html"><strong aria-hidden="true">1.3.5.</strong> C API Reference</a></li></ol></li><li class="chapter-item expanded "><a href="Software/Emulator/index.html"><strong aria-hidden="true">1.4.</strong> Emulator</a></li><li class="chapter-item expanded "><a href="Software/GUI/index.html"><strong aria-hidden="true">1.5.</strong> GUI</a></li></ol></li><li class="chapter-item expanded "><a href="Citation/index.html"><strong aria-hidden="true">2.</strong> Citation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AUTD3 Developers Manual v1.11.1.0</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shinolab/autd3-library-software" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="software"><a class="header" href="#software">Software</a></h1>
<p>This document describes how to use the <a href="https://github.com/shinolab/autd3-library-software.git">autd3 library</a> (hereinafter we called it as <em>SDK</em>).
This SDK is written in C++.
But libraries for other languages are also available, and their usage is described in <a href="Software/./FFI/index.html">FFI</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="about-autd3"><a class="header" href="#about-autd3">About AUTD3</a></h1>
<p>An ultrasound phased array is an ultrasound transducers array, typically arranged in a grid.
By individually controlling the phase and amplitude of ultrasonic waves, an arbitrary sound field can be generated in space.</p>
<p>The convergence of sound energy creates acoustic radiation pressure. 
This pressure enables the human body surface to be pushed in a non-contact manner.
The focal point is generated by the principle of “phased array,” and the focal position can be controlled electronically.
In addition to creating a single focal point, you can create a complex spatial distribution by solving the inverse problem with a computer.</p>
<p>The magnitude of the pressure generated by the phased array is currently up to about <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">N</span></span></span></span></span></span> per square centimeter.
The spatial resolution is up to the used wavelength (e.g., <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">m</span></span></span></span></span></span> at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span>).
Despite these restrictions, you can freely design the spatiotemporal distribution of force within that range and create various tactile sensations.</p>
<p>This area of ​​technology that stimulates tactile sensation in a non-contact manner is called “Midair Haptics,” and we refer to this ultrasound midair haptics device as the Airborne Ultrasound Tactile Display (AUTD).
The essential parts of AUTD were proposed and established by The University of Tokyo between 2008<sup class="footnote-reference"><a href="#1">1</a></sup> and the early 2010s<sup class="footnote-reference"><a href="#2">2</a></sup>.
Since then, some universities and companies from various countries have entered, and R&amp;D has been actively conducted.</p>
<p><a href="https://hapislab.org/airborne-ultrasound-tactile-display">Please also see a list of our studies using AUTD on our laboratory’s website.</a></p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://hapislab.org/public/hiroyuki_shinoda/research/pdf/08Eurohaptics_iwamoto.pdf">Takayuki Iwamoto, Mari Tatezono, and Hiroyuki Shinoda: Non-contact Method for Producing Tactile Sensation Using Airborne Ultrasound, Haptics: Perception, Devices and Scenarios: 6th International Conference, Eurohaptics 2008 Proceedings (Lecture Notes in Computer Science), pp.504-513, 2008.</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://hapislab.org/public/hiroyuki_shinoda/research/pdf/10_Trans_Haptics_Hoshi.pdf">Takayuki Hoshi, Masafumi Takahashi, Takayuki Iwamoto, and Hiroyuki Shinoda: Noncontact Tactile Display Based on Radiation Pressure of Airborne Ultrasound, IEEE Trans. on Haptics, Vol. 3, No. 3, pp.155-165, 2010.</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="users-manual"><a class="header" href="#users-manual">User’s Manual</a></h1>
<p>In this section, the basic usage of the library is described.</p>
<p>Please also refer to the online <a href="https://shinolab.github.io/autd3-library-software/index.html">API Reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="concept"><a class="header" href="#concept">Concept</a></h1>
<p>The primary classes that make up the SDK are as follows,</p>
<ul>
<li><code>Controller</code> - All operations for AUTD3 are performed via this class</li>
<li><code>Geometry</code> - Manage the geometry of devices in the real world</li>
<li><code>Link</code> - Interface to the devices</li>
<li><code>Gain</code> - Class to manage the phase/amplitude of each transducer</li>
<li><code>Modulation</code> - Class to manage Amplitude Modulation (AM)</li>
<li><code>Sequence</code> - Class to manage Spatio-Temporal Modulation (STM) functions on Hardware</li>
</ul>
<p>The flow of using SDK is as follows,</p>
<ul>
<li>Create a <code>Controller</code></li>
<li>Setting the position and orientation of connected devices</li>
<li>Create <code>Link</code>, and connect to devices </li>
<li>Create and send <code>Gain</code>/<code>Sequence</code>, and/or <code>Modulation</code></li>
</ul>
<p>Here is a picture of the AUTD3 from the top.</p>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/autd_trans_idx.jpg"/>
  <figcaption>AUTD front</figcaption>
</figure>
<p>The image of the back of AUTD3 is shown below. 
The connector for the 24V power supply is <em>Molex 5566-02A</em>.</p>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/autd_back.jpg"/>
  <figcaption>AUTD back</figcaption>
</figure>
<p>Each unit of AUTD3 consists of 249 transduces<sup class="footnote-reference"><a href="#fn_asm">1</a></sup>, each of which is assigned an index number as shown in the above figure.
From SDK, the phase/amplitude of all these transducers can be controlled individually in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span></span></span></span></span> resolutions.</p>
<p>The coordinate system of AUTD3 is a right-handed, where the center of the 0-th transducer is the origin.
The <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>-axis is in the direction of the major axis, i.e., 0→17, and the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>-axis is in the direction 0→18.
The unit system in SDK is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">m</span></span></span></span></span></span> for distance, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">d</span></span></span></span></span></span> for angle, and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span> for frequency.
The transducers are arranged at intervals of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">m</span></span></span></span></span></span>, and the total size including the substrate is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">m</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord">5</span><span class="mord">1</span><span class="mord">.</span><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">m</span></span></span></span></span></span>.
The outline drawing of the transducers array is shown below.</p>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/transducers_array.jpg"/>
  <figcaption>Design drawing of transducer array</figcaption>
</figure>
<p>In addition, multiple AUTD3 units can be connected and extended by daisy-chaining.
An extended array can be configured by connecting a PC to the first <code>EherCAT In</code> via an ethernet cable and connecting the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>-th <code>EherCAT Out</code> to the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>-th <code>EherCAT In</code>.
The ethernet cable used must be CAT 5e or higher category.</p>
<div class="footnote-definition" id="fn_asm"><sup class="footnote-definition-label">1</sup>
<p>Three transducers are missing from <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">2</span></span></span></span>. The reason why the screw holes are placed at their positions is to minimize the gaps when multiple units are placed densely.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section will describe how to use AUTD3 in practice.
In the following instructions, Windows 10 64bit will be used, and please modify the instructions appropriately if you use other OS.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>First, install build tools.
The tools and versions used in this section are as follows.
Please follow the official instructions to install each of them.
For Visual Studio Community, install “Desktop Development with C++”.
If you are using Linux, you can use gcc. If you are using macOS, you can use clang.
In addition, since the following instruction will be operated from a terminal, you should set PATH appropriately.</p>
<ul>
<li>Visual Studio Community 2022 17.0.4</li>
<li>CMake 3.22.1</li>
<li>git 2.34.1.windows.1</li>
<li>npcap 1.60</li>
</ul>
<h2 id="setup-device"><a class="header" href="#setup-device">Setup Device</a></h2>
<p>Next, let’s set up the devices.
Here we will use only one AUTD3 device.
Please connect the ethernet port of the PC to the <code>EtherCAT In</code> of the AUTD3 device (see <a href="Software/Users_Manual/concept.html">Concept</a>) with an ethernet cable.
Next, connect the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">V</span></span></span></span></span></span> power supply.</p>
<h3 id="firmware-update"><a class="header" href="#firmware-update">Firmware update</a></h3>
<p>If the firmware is old, the operation is not guaranteed.
The version of firmware in this document is assumed to be 1.9.</p>
<p>To update the firmware, you need a Windows 10 64bit PC with <a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado Design Suite</a> and <a href="https://www.segger.com/downloads/jlink/">J-Link Software</a> installed.
We have confirmed that the update script works with Vivado 2021.1 and J-Link Software v7.58b (x64).</p>
<p>First, connect the AUTD3 device and the PC via <a href="https://www.xilinx.com/products/boards-and-kits/hw-usb-ii-g.html">XILINX Platform Cable</a> and <a href="https://www.segger.com/products/debug-probes/j-link/models/j-link-plus/">J-Link Plus</a> with <a href="https://www.segger-pocjapan.com/j-link-9-pin-cortex-m-adapter">J-Link 9-Pin Cortex-M Adapter</a>, and turn on the AUTD3.
Then, run <code>dist/firmware/autd_firmware_writer.ps1</code> in <a href="https://github.com/shinolab/autd3-library-software">SDK</a>.
The update will take a few minutes.</p>
<h2 id="building-first-program"><a class="header" href="#building-first-program">Building first program</a></h2>
<p>First, open a terminal and prepare an directory.</p>
<pre><code>  mkdir autd3_sample
  cd autd3_sample
</code></pre>
<p>Next, make <code>CMakeLists.txt</code> and <code>main.cpp</code> files.</p>
<pre><code>└─autd3_sample
        CMakeLists.txt
        main.cpp
</code></pre>
<p>Next, download the latest binary version of the SDK.
The binaries are available at <a href="https://github.com/shinolab/autd3-library-software/releases">GitHub Release</a>.
Unzip the downloaded binary, and copy the <code>include</code> and <code>lib</code> folders to the <code>autd3_sample</code> folder.</p>
<pre><code>└─autd3_sample
    │  CMakeLists.txt
    │  main.cpp
    ├─include
    └─lib
</code></pre>
<p>Next, download Eigen3, which is a header-only library for matrix computation.
Here, we change the current directory to <code>autd3_sample</code> and add Eigen3 as git submodule.</p>
<pre><code>  git init
  git submodule add https://gitlab.com/libeigen/eigen.git eigen
  cd eigen
  git checkout 3.4.0
  cd ..
</code></pre>
<p>Alternatively, you can directly download <a href="https://gitlab.com/libeigen/eigen">Eigen3</a> and put it under the <code>autd3_sample</code> folder. The Eigen3 version used in the SDK is 3.4.0.</p>
<p>At this time, the directory structure is as follows.</p>
<pre><code>└─autd3_sample
    │  CMakeLists.txt
    │  main.cpp
    ├─include
    ├─lib
    └─eigen
        ├─bench
        ├─blas
        ├─ci
        ├─cmake
        ...
</code></pre>
<p>Next, write <code>CMakeLists.txt</code> as follows.</p>
<pre><code>cmake_minimum_required(VERSION 3.16)

project(autd3_sample)
set (CMAKE_CXX_STANDARD 17)

add_executable(main main.cpp)

target_compile_definitions(main PRIVATE _USE_MATH_DEFINES)
target_link_directories(main PRIVATE lib)
target_include_directories(main PRIVATE include eigen)

if(WIN32)
  target_link_directories(main PRIVATE lib/wpcap)
  target_link_libraries(main autd3 soem_link Packet.lib wpcap.lib ws2_32.lib winmm.lib)
elseif(APPLE)
  target_link_libraries(main pcap)
else()
  target_link_libraries(main rt)
endif()

if(WIN32)
    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT main)
endif()
</code></pre>
<p>And, write <code>main.cpp</code> as follows.
This source code will apply <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span> AM modulation to a single focus at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">m</span></span></span></span></span></span> above of center of the array.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

#include &quot;autd3.hpp&quot;
#include &quot;autd3/link/soem.hpp&quot;

using namespace std;
using namespace autd;

string get_adapter_name() {
  size_t i = 0;
  const auto adapters = link::SOEM::enumerate_adapters();
  for (auto&amp;&amp; [desc, name] : adapters) cout &lt;&lt; &quot;[&quot; &lt;&lt; i++ &lt;&lt; &quot;]: &quot; &lt;&lt; desc &lt;&lt; &quot;, &quot; &lt;&lt; name &lt;&lt; endl;

  cout &lt;&lt; &quot;Choose number: &quot;;
  string in;
  getline(cin, in);
  stringstream s(in);
  if (const auto empty = in == &quot;\n&quot;; !(s &gt;&gt; i) || i &gt;= adapters.size() || empty) return &quot;&quot;;

  return adapters[i].name;
}

int main() try {
  autd::Controller autd;

  autd.geometry().add_device(Vector3(0, 0, 0), Vector3(0, 0, 0));

  const auto ifname = get_adapter_name();
  auto link = link::SOEM::create(ifname, autd.geometry().num_devices());
  autd.open(std::move(link));

  autd.clear();

  auto firm_info_list = autd.firmware_info_list();
  for (auto&amp;&amp; firm_info : firm_info_list) cout &lt;&lt; firm_info &lt;&lt; endl;

  autd.silent_mode() = true;

  const auto focus = Vector3(TRANS_SPACING_MM * ((NUM_TRANS_X - 1) / 2.0), TRANS_SPACING_MM * ((NUM_TRANS_Y - 1) / 2.0), 150.0);
  gain::FocalPoint g(focus);
  modulation::Sine m(150);
  autd &lt;&lt; g, m;

  cout &lt;&lt; &quot;press enter to finish...&quot; &lt;&lt; endl;
  cin.ignore();

  autd.close();

  return 0;
} catch (exception&amp; ex) {
  cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>
<p>Then, build with CMake.</p>
<pre><code>  mkdir build
  cd build
  cmake .. -G &quot;Visual Studio 17 2022&quot; -A x64
</code></pre>
<p><code>autd3_sample.sln</code> should be generated under the <em>build</em> directory, so open it and run the <em>main</em> project.
<strong>Note that you should change the build configuration of Visual Studio from Debug to Release</strong>.
In case of Linux/macOS, you may need to run the program as root user.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>Here, we will explain the above codes.</p>
<p>To use the SDK, include the <code>autd3.hpp</code> header.
You also need <code>autd3/link/soem.hpp</code> to use <code>link::SOEM</code>.</p>
<pre><code class="language-cpp">#include &quot;autd3.hpp&quot;
#include &quot;autd3/link/soem.hpp&quot;
</code></pre>
<p>Then, create <code>Controller</code> instance.</p>
<pre><code class="language-cpp">  autd::Controller autd;
</code></pre>
<p>After that, we specify the geometry of the device in the real world.</p>
<pre><code class="language-cpp">  autd.geometry().add_device(autd::Vector3(0, 0, 0), autd::Vector3(0, 0, 0));
</code></pre>
<p>The first argument of <code>add_device</code> is the position, the second argument is the rotation.
The position is 0-th transducer position in the global coordinate system you set.
The rotation is specified by ZYZ euler angles or quaternions.
Here, we assume that the device is placed at global origin without rotation.</p>
<p>Next, create <code>Link</code>, and connect to the device.</p>
<pre><code class="language-cpp">  const auto ifname = get_adapter_name();
  auto link = link::SOEM::create(ifname, autd.geometry().num_devices());
  autd.open(std::move(link));
</code></pre>
<p>The first argument of <code>link::SOEM::create()</code> is the ethernet interface name where the AUTD3 device is connected, and the second argument is the number of AUTD3 devices connected. 
We prepared a utility function <code>get_adapter_name</code> to get the interface name list, so please select the appropriate one at runtime.
(On macOS or Linux, you can also use <code>ifconfig</code> to check it.)</p>
<p>Then, initialize the AUTD devices.
You may not need to call <code>clear()</code> since it is initialized at power-on.</p>
<pre><code class="language-cpp">  autd.clear();
</code></pre>
<p>Next, we check the version of the firmware.
This operation is not required to run AUTD3.</p>
<pre><code class="language-cpp">  auto firm_info_list = autd.firmware_info_list();
  for (auto&amp;&amp; firm_info : firm_info_list) cout &lt;&lt; firm_info &lt;&lt; endl;
</code></pre>
<p>Next, we set <em>silent mode</em> on.</p>
<pre><code class="language-cpp">  autd.silent_mode() = true;
</code></pre>
<p>Since it is on by default, you don’t need to call it in fact.
If you want to turn it off, please give <code>false</code>.
In <em>silent mode</em>, the phase/amplitude parameters given to the transducer are passed through a low-pass filter to reduce noise.</p>
<p>After that, send the <code>Modulation</code> which applies <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span> Sin wave amplitude modulation and the <code>Gain</code> which represents the single focus.</p>
<pre><code class="language-cpp">  const auto point = autd::Vector3(autd::TRANS_SPACING_MM * ((autd::NUM_TRANS_X - 1) / 2.0), autd::TRANS_SPACING_MM * ((autd::NUM_TRANS_Y - 1) / 2.0), 150.0);
  autd::gain::FocalPoint g(point);
  autd::modulation::Sine m(150);
  autd &lt;&lt; g, m;
</code></pre>
<p>The <code>point</code> is a bit complicated; <code>TRANS_SPACING_MM</code> represents the spacing of the transducers, and <code>NUM_TRANS_X</code> and <code>NUM_TRANS_Y</code> represent the number of transducers in the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>-axis, respectively.
Therefore, <code>point</code> represents the point <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">m</span></span></span></span></span></span> right above the center of the transducers array.</p>
<p>Finally, you should disconnect the device.</p>
<pre><code class="language-cpp">  autd.close();
</code></pre>
<p>In the next section, we will describe the basic functions.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="geometry"><a class="header" href="#geometry">Geometry</a></h1>
<p>In this section, we describe Geometry, which manages how AUTD3 devices are placed in the real world.</p>
<h2 id="multiple-devices"><a class="header" href="#multiple-devices">Multiple devices</a></h2>
<p>AUTD3 devices can be daisy-chained to each other.
To connect multiple devices, connect the PC to the first <code>EtherCAT In </code> with a ethernet cable, and connect the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>-th <code>EtherCAT Out</code> to the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>-th <code>EtherCAT In</code> with a ethernet cables (see <a href="Software/Users_Manual/concept.html">Concept</a>).
The power supply can also be daisy-chained, and you can use any of the three power supply connectors.</p>
<p>If you want to use multiple devices in the SDK, call the <code>add_device</code> function for each connected device.
The first argument of the <code>add_device</code> function is the position and the second argument is the rotation.
The rotation is specified by ZYZ euler angles or Quaternion.</p>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/autd_hori.jpg"/>
  <figcaption>Horizontal alignment</figcaption>
</figure>
<p>For example, suppose that the devices are arranged and connected as shown in the figure above, and the device on the left is the first device that is connected to the PC and the device on the right is the second device.
Assuming that the first device is placed at the global origin, you should call <code>add_device</code> as follows,</p>
<pre><code class="language-cpp">  autd.geometry().add_device(autd::Vector3(0, 0, 0), autd::Vector3(0, 0, 0));
  autd.geometry().add_device(autd::Vector3(autd::DEVICE_WIDTH, 0, 0), autd::Vector3(0, 0, 0));
</code></pre>
<p>Here, <code>autd::DEVICE_WIDTH</code> is the width of the device (including the circuit board outline).
Since there is no rotation, the second argument should be <code>(0, 0, 0)</code>.</p>
<p>Or, for example, if you place the second device at the global origin, you should,</p>
<pre><code class="language-cpp">  autd.geometry().add_device(autd::Vector3(-autd::DEVICE_WIDTH, 0, 0), autd::Vector3(0, 0, 0));
  autd.geometry().add_device(autd::Vector3(0, 0, 0), autd::Vector3(0, 0, 0));
</code></pre>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/autd_vert.jpg"/>
  <figcaption>Vertical alignment</figcaption>
</figure>
<p>For another example, if two devices are placed as shown in the figure above, with the first one on the bottom and the second one on the left, and the first device is placed at the global origin, you should specify the rotation as follows,</p>
<pre><code class="language-cpp">  autd.geometry().add_device(autd::Vector3(0, 0, 0), autd::Vector3(0, 0, 0));
  autd.geometry().add_device(autd::Vector3(0, 0, autd::DEVICE_WIDTH), autd::Vector3(0, M_PI / 2.0, 0));
</code></pre>
<p>The global coordinate system is used in all SDK APIs, so you can use APIs transparently even when multiple devices are connected.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="link"><a class="header" href="#link">Link</a></h1>
<p><em>Link</em> is the interface to the AUTD3 device.
You need to choose one of the following.</p>
<h2 id="twincat"><a class="header" href="#twincat">TwinCAT</a></h2>
<p>TwinCAT is the only official way to use EherCAT on a PC.
TwinCAT is a very special software which only supports Windows and makes Windows real-time.</p>
<p>TwinCAT requires a specific network controller, please check <a href="https://infosys.beckhoff.com/english.php?content=../content/1033/tc3_overview/9309844363.html&amp;id=">supported network controllers list</a>.</p>
<blockquote>
<p>Note: Alternatively, after installing TwinCAT, you can find the <em>Vendor ID</em> and <em>Device ID</em> of the supported network controller in <code>C:/TwinCAT/3.1/Driver/System/TcI8254x.inf</code>.</p>
</blockquote>
<h3 id="how-to-install-twincat"><a class="header" href="#how-to-install-twincat">How to install TwinCAT</a></h3>
<p>TwinCAT cannot coexist with Hyper-V and Virtual Machine Platform.
Therefore, you need to disable these features.
To do this, for example, run PowerShell with administrative privileges, and enter following commands,</p>
<pre><code>Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
Disable-WindowsOptionalFeature -online -featurename VirtualMachinePlatform
</code></pre>
<p>First, download <em>TwinCAT XAE</em> from the <a href="https://www.beckhoff.com/en-en/">official website</a>.
Registration (free) is required to download the software.</p>
<p>Then, launch the installer and follow the instructions.
<strong>At this time, check “TwinCAT XAE Shell install” and uncheck “Visual Studio Integration”.</strong></p>
<p>After the installation, reboot and then run <code>C:/TwinCAT/3.1/System/win8settick.bat</code> with administrator privileges and reboot again.</p>
<p>Finally, copy the file <code>AUTDServer/AUTD.xml</code> in the SDK to <code>C:/TwinCAT/3.1/Config/Io/EtherCAT</code>.</p>
<h3 id="autdserver"><a class="header" href="#autdserver">AUTDServer</a></h3>
<p>To use TwinCAT Link, run <code>AUTDServer/AUTDServer.exe</code> in advance.
After executing AUTDServer, you will be prompted to enter your IP address, but please leave it empty.
Then, a TwinCAT XAE Shell will be launched.
Finally, you will be asked to close the shell.
If you use AUTDServer at the first time, please enter <code>No</code> and follow the instructions below to setup </p>
<blockquote>
<p>Note: If you close it, you can open AUTDServer shell by launching <code>%Temp%/TwinCATAUTDServer/TwinCATAUTDServer.sln</code> as TcXaeShell Application, where <code>%Temp%</code> is an environment variable, usually <code>C:/Users/(user name)/AppData/Local/Temp</code>.</p>
</blockquote>
<p>Note that AUTDServer (i.e. TwinCAT) will break the link when you turn off your PC, enter the sleep mode, etc., so you should re-run AUTDServer each time.</p>
<h4 id="install-driver"><a class="header" href="#install-driver">Install Driver</a></h4>
<p>For the first time, you need to install a driver for EtherCAT.
From the top menu of the TwinCAT XAE Shell, go to “TwinCAT” -&gt; “Show Realtime Ethernet Compatible Devices” and select a compatible device from the list of compatible devices and click on Install.
If nothing is shown in the compatible devices, the network controllers of the PC are not compatible with TwinCAT.</p>
<h4 id="licensing"><a class="header" href="#licensing">Licensing</a></h4>
<p>The first time you run the program, you will get an error related to the license, so open “Solution Explorer” -&gt; “SYSTEM” -&gt; “License” in XAE Shell, and click “7 Days Trial License …”. and enter the text displayed on the screen.
Note that the license is a 7-day trial license, but can be reissued when it expires by performing the same procedure again.
After the license is issued, close the XAE Shell and run “AUTDServer.exe” again.</p>
<h3 id="trouble-shooting"><a class="header" href="#trouble-shooting">Trouble shooting</a></h3>
<p>If you try to use a large number of devices, you may get an error like the figure below.
In this case, multiply the values of <code>TaskCycleTime</code> and <code>Sync0Cycletime</code> in <code>settings.ini</code> by an integer, and run AUTDServer again.
Roughly speaking, <code>TaskCycleTime</code> means the interval of data update, and <code>Sync0Cycletime</code> means the interval of synchronization signal firing.
Therefore, you should choose as small values as possible.
How many times the value depends on the number of connected devices.
For example, when you have 9 devices, it should work if you multiply the number by 2.</p>
<pre><code>TaskCycleTime=20000
CPUbaseTime=10000
Sync0Cycletime=1000000
</code></pre>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/tcerror.jpg"/>
  <figcaption>TwinCAT error when using 9 devices</figcaption>
</figure>
<h2 id="remotetwincat"><a class="header" href="#remotetwincat">RemoteTwinCAT</a></h2>
<p>As mentioned above, TwinCAT requires a Windows OS and a specific network adapter.
If you want to use develop client applications on non-Windows PCs, you can use RemoteTwinCAT link to control TwinCAT remotely.
(SOEM link described below also works on cross-platform).</p>
<p>To use RemoteTwinCAT, you need to prepare two PCs.
One of the PCs must be able to use TwinCAT link described above.
Herein, we call this PC a “server”.
On the other hand, the PC on the development side, i.e., the one that uses the SDK, has no restriction, but is required to be connected to the same LAN as the server, which we call the “client”.</p>
<p>First, please connect the “server” to the AUTD device.
In this case, the LAN adapter used must be TwinCAT compatible, as in the TwinCAT link.
Also, connect the server and the client with another LAN.
This LAN adapter does not need to be TwinCAT compatible <sup class="footnote-reference"><a href="#fn_remote_twin">1</a></sup>.
Then, check the IP of the LAN between the server and the client.
For example, let’s assume that the server IP is “169.254.205.219” and the client IP is “169.254.175.45”.
Next, start AUTDServer on the “server”.
After starting, you will be asked to enter the IP, where you should enter the IP of the client side (<code>169.254.175.45</code> in this example).
Then, enter “No” at the end to leave TwinCATAUTDServer open.
As shown in the following figure, open “SYSTEM“→“Routes” and check <em>AmsNetId</em> in Current Route tab and <em>Local NetId</em> in NetId Management tab.</p>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/Current_Route.jpg"/>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/NetId_Management.jpg"/>
  <figcaption>AmsNetId/Local NetId</figcaption>
</figure>
<p>Let’s assume that <em>AmsNetId</em> and <em>Local NetId</em> are “169.254.175.45.1.1” and “172.16.99.194.1.1”, respectively.
In this case, the client side should include the <code>autd3/link/remote_twincat.hpp</code> header, and use RemoteTwinCAT link as,</p>
<pre><code class="language-cpp">#include &quot;autd3/link/remote_twincat.hpp&quot;

...
  const std::string remote_ipv4_addr = &quot;169.254.205.219&quot;;
  const std::string remote_ams_net_id = &quot;172.16.99.194.1.1&quot;;
  const std::string local_ams_net_id = &quot;169.254.175.45.1.1&quot;;
  auto link = autd::link::RemoteTwinCAT::create(remote_ipv4_addr, remote_ams_net_id, local_ams_net_id);
</code></pre>
<p>If you get TCP-related errors, there is a possibility that the ADS protocol is blocked by firewall.
If so, configure your firewall to allow connections on port 48898 of TCP/UDP.</p>
<h2 id="soem"><a class="header" href="#soem">SOEM</a></h2>
<p><a href="https://github.com/OpenEtherCATsociety/SOEM">SOEM</a> is an open-source EherCAT Master library.
Unlike TwinCAT, SOEM runs on ordinary Windows, so its real-time performance is not guaranteed.
Therefore, it is recommended to use TwinCAT in principle.
SOEM should be used only when there is a compelling reason to use it, or only during development.
On the other hand, SOEM has the advantage of cross-platform operation and simple installation.</p>
<p>For Windows, you should install <a href="https://nmap.org/npcap/">npcap</a> or <a href="https://www.winpcap.org/">WinPcap</a> in advance.
npcap is the successor of WinPcap, and we recommend you to use it.
<strong>Note that npcap should be installed with “WinPcap API compatible mode”.</strong>
For Linux/macOS, no special preparation is required.</p>
<p>Please include <code>autd3/link/soem.hpp</code> to use SOEM link.</p>
<pre><code class="language-cpp">#include &quot;autd3/link/soem.hpp&quot;

...

  auto link = autd::link::SOEM::create(ifname, autd.geometry().num_devices());
</code></pre>
<p>The first argument of <code>SOEM::create</code> is the interface name and the second argument is the number of devices.
The interface name is the name of the ethernet interface connected to the AUTD3 device.
The interface list can be retrieved by the <code>SOEM::enumerate_adapters</code> function.</p>
<pre><code class="language-cpp">  const auto adapters = autd::link::SOEM::enumerate_adapters();
  for (auto&amp;&amp; [desc, name] : adapters) std::cout &lt;&lt; desc &lt;&lt; &quot;, &quot; &lt;&lt; name &lt;&lt; std::endl;
</code></pre>
<p>Note that SOEM sometimes becomes unstable when a large number of devices are used.
In this case, increase the value of the third argument of <code>create</code> (<code>cycle_ticks</code>) (default is 1).</p>
<pre><code class="language-cpp">  const uint32_t cycle_ticks = 2;
  auto link = autd::link::SOEM::create(ifname, autd.geometry().num_devices(), cycle_ticks);
</code></pre>
<p>The <code>cycle_ticks</code> controls the data update interval and the firing period of the synchronization signal.
The default values of the data update interval and the firing period of the synchronization signal are <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="mord mathrm">s</span></span></span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="mord mathrm">s</span></span></span></span></span></span>, respectively, which are multiplied by the value of <code>cycle_ticks</code>.
Therefore, it is recommended to choose the smallest possible value.</p>
<p>SOEM Link can also be configured with a callback when an unrecoverable error occurs (e.g., a cable is disconnected)<sup class="footnote-reference"><a href="#fn_soem_err">2</a></sup>.
The callback takes an error message as an argument.</p>
<pre><code class="language-cpp">  link-&gt;on_lost([](const std::string&amp; msg) {
    std::cerr &lt;&lt; &quot;Link is lost\n&quot;;
    std::cerr &lt;&lt; msg;
    std::quick_exit(-1);
  });
</code></pre>
<h2 id="emulator"><a class="header" href="#emulator">Emulator</a></h2>
<p>Emulator link is a link to use <a href="https://github.com/shinolab/autd-emulator">AUTD Emulator</a> (which will be described after).</p>
<p>Before using it, you need to run the AUTD Emulator.</p>
<p>To use Emulator link, include the <code>autd3/link/emulator.hpp</code> .</p>
<pre><code class="language-cpp">#include &quot;autd3/link/emulator.hpp&quot;

...

  auto link = autd::link::Emulator::create(50632, autd.geometry());
</code></pre>
<p>The first argument of <code>Emulator::create</code> is a port number (default is 50632), and the second argument is Geometry.</p>
<div class="footnote-definition" id="fn_remote_twin"><sup class="footnote-definition-label">1</sup>
<p>Wireless LAN also can be used.</p>
</div>
<div class="footnote-definition" id="fn_soem_err"><sup class="footnote-definition-label">2</sup>
<p>Since it is not recoverable, the only thing you can do is terminate the program immediately.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="gain"><a class="header" href="#gain">Gain</a></h1>
<p>This SDK can control the phase/amplitude of each transducer individually, which allows to generate various sound fields.
<code>Gain</code> is a class to manage this, and the SDK provides <code>Gain</code>s for generating several kinds of sound fields by default.</p>
<h2 id="focalpoint"><a class="header" href="#focalpoint">FocalPoint</a></h2>
<p><code>FocalPoint</code> is the simplest <code>Gain</code>, which produces a single focus.</p>
<pre><code class="language-cpp">    autd::gain::FocalPoint g(autd::Vector3(x, y, z));
</code></pre>
<p>The first argument of constructor is the position of the focus.
As the second argument, you can specify the amplitude as a duty ratio (<code>uint8_t</code>) or a normalized sound pressure amplitude from 0 to 1 (<code>double</code>).</p>
<p>Here we note the relationship between the duty ratio <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> and the sound pressure <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>.
Theoretically,
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></span>
Therefore, the sound pressure takes the minimum value <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> at duty ratio <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and the maximum value at duty ratio <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord"><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">%</span></span></span></span></span></span>, but the relationship between them is not linear.
In the case of specifying the sound pressure amplitude, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> is taken as the maximum value, and it is internally converted to duty ratio by the inverse conversion of the above equation.</p>
<h2 id="besselbeam"><a class="header" href="#besselbeam">BesselBeam</a></h2>
<p><code>BesselBeam</code> Gain generates a Bessel beam.
This <code>Gain</code> is based on the paper by Hasegawa et al.[hasegawa2017].</p>
<pre><code class="language-cpp">  const autd::Vector3 apex(x, y, z);
  const autd::Vector3 dir = autd::Vector3::UnitZ();
  const double theta_z = 0.3;
  autd::gain::BesselBeam g(apex, dir, theta_z);
</code></pre>
<p>The first argument of constructor is the apex of the virtual cone that generates the beam, the second argument is the direction of the beam, and the third argument is the angle between the plane perpendicular to the beam and the side of the virtual cone (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the figure below).
As the fourth argument, the amplitude can be specified as a duty ratio (<code>uint8_t</code>) or a normalized sound pressure amplitude of 0-1 (<code>double</code>).</p>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/1.4985159.figures.online.f1.jpg"/>
  <figcaption>Bessel beam (cited from [hasegawa2017])</figcaption>
</figure>
<h2 id="planewave"><a class="header" href="#planewave">PlaneWave</a></h2>
<p><code>PlaneWave</code> Gain generates plane wave.</p>
<pre><code class="language-cpp">    autd::gain::PlaneWave g(autd::Vector3(x, y, z));
</code></pre>
<p>The first argument of constructor is the direction of the plane wave.
As the second argument, you can specify the amplitude as a duty ratio (<code>uint8_t</code>) or a normalized sound pressure amplitude from 0 to 1 (<code>double</code>).</p>
<h2 id="transducertest"><a class="header" href="#transducertest">TransducerTest</a></h2>
<p><code>TransducerTest</code> Gain drives a single transducer for debugging.</p>
<pre><code class="language-cpp">    autd::gain::TransducerTest g(index, duty, phase);
</code></pre>
<p>The first argument of constructor is the index of the transducer, the second argument is the duty ratio, and the third argument is the phase.</p>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<p><code>Null</code> Gain is <code>Gain</code> with zero amplitudes, so it produces nothing.</p>
<pre><code class="language-cpp">    autd::gain::Null g();
</code></pre>
<h2 id="holo-multiple-foci"><a class="header" href="#holo-multiple-foci">Holo (Multiple foci)</a></h2>
<p><code>Holo</code> is a <code>Gain</code> for generating multi-foci.
Several algorithms have been proposed to generate multi-foci, and the following algorithms are implemented in the SDK.</p>
<ul>
<li><code>SDP</code> - Semidefinite programming, based on [inoue2015]</li>
<li><code>EVD</code> - Eigen value decomposition, based on [long2014]</li>
<li><code>Naive</code> - Linear synthesis of single-focus solutions</li>
<li><code>GS</code> - Gershberg-Saxon, based on [marzo2019]</li>
<li><code>GSPAT</code> - Gershberg-Saxon for Phased Arrays of Transducers, based on [plasencia2020]</li>
<li><code>LM</code> - Levenberg-Marquardt, based on [levenberg1944, marquardt1963, madsen2004]</li>
<li><code>GaussNewton</code> - Gauss-Newton</li>
<li><code>GradientDescent</code> - Gradient descent</li>
<li><code>APO</code> - Acoustic Power Optimization, based on [hasegawa2020]</li>
<li><code>Greedy</code> - Greedy algorithm and Brute-force search, based on [suzuki2021]</li>
</ul>
<p>In addition, each method has a choice of computational backend.
The following <code>Backend</code> is provided in the SDK.</p>
<ul>
<li><code>EigenBackend</code> - uses <a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>. This backend is enabled by default.</li>
<li><code>BLASBackend</code> - uses BLAS/LAPACK such as <a href="https://www.openblas.net/">OpenBLAS</a> and <a href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/onemkl.html">Intel MKL</a></li>
<li><code>CUDABackend</code> - uses CUDA. This backend runs on GPU. </li>
<li><code>ArrayFireBackend</code> - uses <a href="https://arrayfire.com/">ArrayFire</a></li>
</ul>
<p>To use <code>Holo</code> Gain, include <code>autd3/gain/holo.hpp</code> and the header of each <code>Backend</code>.</p>
<pre><code class="language-cpp">#include &quot;autd3/gain/eigen_backend.hpp&quot;
#include &quot;autd3/gain/holo.hpp&quot;

...

  const auto backend = autd::gain::holo::EigenBackend::create();
  autd::gain::holo::SDP g(backend, foci, amps);
</code></pre>
<p>The first argument of each constructor is a <code>backend</code>, the second argument is a <code>vector</code> of <code>autd::Vector3</code> for the position of each focus, and the third argument is a <code>vector</code> of <code>double</code> for the sound pressure of each focus.
In addition, there are additional parameters for each algorithm.
For details of each parameter, please refer to the respective papers.</p>
<p>If you want to use a <code>Backend</code> other than Eigen, you need to compile the respective <code>Backend</code> library on your own<sup class="footnote-reference"><a href="#fn_backend">1</a></sup>.</p>
<h3 id="blas-backend"><a class="header" href="#blas-backend">BLAS Backend</a></h3>
<p>To build the BLAS backend, set the <code>BUILD_BLAS_BACKEND</code> flag on, specify the directory of BLAS library with <code>BLAS_LIB_DIR</code>, the directory of BLAS <code>include</code> with <code>BLAS_INCLUDE_DIR</code>, and the vendor of BLAS with <code>BLA_VENDO</code> in CMake,</p>
<pre><code>cmake .. -DBUILD_HOLO_GAIN=ON -DBUILD_BLAS_BACKEND=ON -DBLAS_LIB_DIR=&lt;your BLAS library path&gt; -DBLAS_INCLUDE_DIR=&lt;your BLAS include path&gt; -DBLA_VENDOR=&lt;your BLAS vendor&gt;
</code></pre>
<p>If you use Intel MKL, please set <code>USE_MKL</code> flag on,</p>
<pre><code>cmake .. -DBUILD_HOLO_GAIN=ON -DBUILD_BLAS_BACKEND=ON -DBLAS_LIB_DIR=&lt;your BLAS library path&gt; -DBLAS_INCLUDE_DIR=&lt;your BLAS include path&gt; -DBLA_VENDOR=Intel10_64lp -DUSE_MKL=ON
</code></pre>
<h4 id="openblas-install-example-for-windows"><a class="header" href="#openblas-install-example-for-windows">OpenBLAS install example for Windows</a></h4>
<p>Here is an installation example for Windows of <a href="https://github.com/xianyi/OpenBLAS">OpenBLAS</a>, one of the BLAS implementations.
Please also refer to the <a href="https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio">Official explanation</a>.
We have confirmed that it works with OpenBLAS version 0.3.18.</p>
<p>First, install Visual Studio 2022 and Anaconda (or miniconda), and open <em>Anaconda Prompt</em>.
On the Anaconda Prompt, type the following commands in order.
Note that we install OpenBLAS in <code>D:/lib/openblas</code>.
You can set this to any location you like.</p>
<pre><code>git clone https://github.com/xianyi/OpenBLAS
cd OpenBLAS
conda update -n base conda
conda config --add channels conda-forge
conda install -y cmake flang clangdev perl libflang ninja
&quot;c:/Program Files/Microsoft Visual Studio/2022/Community/VC/Auxiliary/Build/vcvars64.bat&quot;
set &quot;LIB=%CONDA_PREFIX%\Library\lib;%LIB%&quot;
set &quot;CPATH=%CONDA_PREFIX%\Library\include;%CPATH%&quot;
mkdir build
cd build
cmake .. -G &quot;Ninja&quot; -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl -DCMAKE_Fortran_COMPILER=flang -DCMAKE_MT=mt -DBUILD_WITHOUT_LAPACK=no -DNOFORTRAN=0 -DDYNAMIC_ARCH=ON -DCMAKE_BUILD_TYPE=Release
cmake --build . --config Release
cmake --install . --prefix D:\lib\openblas -v
</code></pre>
<p>You may also need to add <code>%CONDA_HOME%/Library/bin</code> to your PATH, where <code>%CONDA_HOME%</code> is the home directory of Anaconda (or miniconda).</p>
<p>If you follow this installation example, you can build BLAS backend as follows.</p>
<pre><code>cmake .. -DBUILD_HOLO_GAIN=ON -DBUILD_BLAS_BACKEND=ON -DBUILD_BLAS_BACKEND=ON -DBLAS_LIB_DIR=D:/lib/openblas -DBLAS_INCLUDE_DIR=D:/lib/openblas/include/openblas -DBLA_VENDOR=OpenBLAS
</code></pre>
<p>If you get <code>flangxxx.lib</code> link errors, you should set Anaconda <code>lib</code> directory as <code>BLAS_DEPEND_LIB_DIR</code>.</p>
<pre><code>cmake .. -DBUILD_HOLO_GAIN=ON -DBUILD_BLAS_BACKEND=ON -DBUILD_BLAS_BACKEND=ON -DBLAS_LIB_DIR=D:/lib/openblas -DBLAS_INCLUDE_DIR=D:/lib/openblas/include/openblas -DBLA_VENDOR=OpenBLAS -DBLAS_DEPEND_LIB_DIR=%CONDA_HOME%/Library/lib
</code></pre>
<h3 id="cuda-backend"><a class="header" href="#cuda-backend">CUDA Backend</a></h3>
<p>To build a CUDA backend, install <a href="https://developer.nvidia.com/cuda-toolkit">CUDA Toolkit</a> and set <code>BUILD_CUDA_BACKEND</code> flag in CMake.</p>
<pre><code class="language-cpp">  cmake .. -DBUILD_HOLO_GAIN=ON -DBUILD_CUDA_BACKEND=ON
</code></pre>
<p>We have confirmed that it works with CUDA Toolkit version 11.5.50.</p>
<h3 id="arrayfire-backend"><a class="header" href="#arrayfire-backend">ArrayFire Backend</a></h3>
<p>To build a ArrayFire backend, install [ArrayFire]https://arrayfire.com) and set <code>BUILD_ARRAYFIRE_BACKEND</code> flag in CMake.</p>
<pre><code class="language-cpp">  cmake .. -DBUILD_HOLO_GAIN=ON -DBUILD_ARRAYFIRE_BACKEND=ON
</code></pre>
<p>We have confirmed that it works with CUDA Toolkit version 3.8.0.</p>
<h2 id="grouped"><a class="header" href="#grouped">Grouped</a></h2>
<p><code>Grouped</code> Gain is a <code>Gain</code> that allows you to use different <code>Gain</code>s for each device when using multiple devices.</p>
<p>In <code>Grouped</code>, you can associate an arbitrary <code>Gain</code> to device id.</p>
<pre><code class="language-cpp">#include &quot;autd3/gain/eigen_backend.hpp&quot;
#include &quot;autd3/gain/holo.hpp&quot;

...

  const auto g0 = ...;
  const auto g1 = ...;

  autd::gain::Grouped g(autd.geometry());
  g.add(0, g0);
  g.add(1, g1);
</code></pre>
<p>In the above case, device 0 uses <code>Gain g0</code> and device 1 uses <code>Gain g1</code>.</p>
<h2 id="create-custom-gain-tutorial"><a class="header" href="#create-custom-gain-tutorial">Create Custom Gain Tutorial</a></h2>
<p>By inheriting from the <code>Gain</code> class, you can create your own <code>Gain</code>.
In this section, we will define <code>Focus</code> which generates a single focus.</p>
<p>The essence of <code>Gain</code> is <code>vector&lt;Drive&gt; _data</code>, where <code>Drive</code> class contains phase and duty ratio of transducer.
Below is a sample of the <code>Gain</code> that generates a single focus.</p>
<pre><code class="language-cpp">#include &quot;autd3.hpp&quot;
#include &quot;autd3/core/utils.hpp&quot;

class Focus final : public autd::core::Gain {
 public:
  explicit Focus(const autd::Vector3 point) : _point(point) {}

  void calc(const autd::Geometry&amp; geometry) override {
    const auto wavenum = 2.0 * M_PI / geometry.wavelength();
    for (const auto&amp; device : geometry)
      for (const auto&amp; transducer : device) {
        const auto dist = (transducer.position() - this-&gt;_point).norm();
        this-&gt;_data[transducer.id()].duty = 0xFF;
        this-&gt;_data[transducer.id()].phase = autd::core::utils::to_phase(dist * wavenum);
      }
  } 

 private:
  autd::Vector3 _point;
};
</code></pre>
<p><code>Controller::send</code> function takes a <code>GainPtr</code> type (an alias of <code>shared_ptr&lt;autd::core::Gain&gt;</code>) as an argument.
Therefore, you should define a <code>create</code> function to return it.
In the example, since we want to create a single focus, we pass the focus position as an argument.</p>
<p>If you pass <code>GainPtr</code> to <code>Controller::send</code>, the method <code>Gain::calc</code> will be called internally.
So, you should calculate the phase/amplitude in the <code>calc</code> method.</p>
<p>For the duty ratio <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mclose">]</span></span></span></span> of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span></span></span></span></span> specified by SDK and the phase <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mclose">]</span></span></span></span> of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span></span></span></span></span>, the ultrasonic sound pressure <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> radiated from the transducer will be modeled as,
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03194em;">r</span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">offset</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">e</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0040200000000001em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">λ</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mord mtight">∥</span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord boldsymbol mtight" style="margin-right:0.03194em;">r</span></span></span></span><span class="mord mtight">∥</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">e</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0234649999999998em;"><span style="top:-3.4130000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8720928571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span>
Here, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">λ</span></span></span></span> is the wavelength.
Also, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">offset</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">offset</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> by default, which can be changed optionally.
Therefore, the sound pressure is maximum at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span><sup class="footnote-reference"><a href="#fn_duty">2</a></sup>.</p>
<p>In order to maximize the sound pressure of the ultrasound emitted from a large number of transducers at a certain point <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span></span></span></span></span>, the phase at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">p</span></span></span></span></span></span></span> should be aligned.
Therefore, we have to set <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> as,
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">λ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∥</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03194em;">r</span></span></span></span><span class="mord">∥</span><span class="mpunct">,</span></span></span></span></span>
where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> is the distance between the transducer and the focal point.</p>
<p>In SDK, you can get the wavelength by <code>Geometry::wavelength()</code>.
An iterator which returns <code>Device</code> iterator is defined for <code>Geometry</code>, and an iterator which returns <code>Transducer</code> iterator is also defined for <code>Device</code>.
You can get transducer position from <code>Transducer</code> struct.
The <code>autd::core::Utilities::to_phase</code> function is a utility function to convert the above phase <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">d</span></span></span></span></span></span> to the internal representation <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> of SDK, defined as follows<sup class="footnote-reference"><a href="#fn_phase">3</a></sup>.</p>
<pre><code class="language-cpp">  inline static uint8_t to_phase(const double phase) noexcept {
    return static_cast&lt;uint8_t&gt;(static_cast&lt;int&gt;(std::round((phase / (2.0 * M_PI) + 0.5) * 256.0)) &amp; 0xFF);
  }
</code></pre>
<div class="footnote-definition" id="fn_backend"><sup class="footnote-definition-label">1</sup>
<p>You need to compile it from the source code. It is not included in the pre-built binary uploaded to GitHub.</p>
</div>
<div class="footnote-definition" id="fn_duty"><sup class="footnote-definition-label">2</sup>
<p>In the case of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">offset</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, it seems that the amplitude does not become zero even if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, but as far as we checked with the oscilloscope, the input signal to the transducer disappears, so there is no problem in fact.</p>
</div>
<div class="footnote-definition" id="fn_phase"><sup class="footnote-definition-label">3</sup>
<p>The reason for <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span> is that the return value of <code>std::arg</code> etc. is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">]</span></span></span></span>.</p>
</div>
<p>[hasegawa2017]: Hasegawa, Keisuke, et al. “Electronically steerable ultrasound-driven long narrow air stream.” Applied Physics Letters 111.6 (2017): 064104.</p>
<p>[inoue2015]: Inoue, Seki, Yasutoshi Makino, and Hiroyuki Shinoda. “Active touch perception produced by airborne ultrasonic haptic hologram.” 2015 IEEE World Haptics Conference (WHC). IEEE, 2015.</p>
<p>[long2014]: Long, Benjamin, et al. “Rendering volumetric haptic shapes in mid-air using ultrasound.” ACM Transactions on Graphics (TOG) 33.6 (2014): 1-10.</p>
<p>[marzo2019]: Marzo, Asier, and Bruce W. Drinkwater. “Holographic acoustic tweezers.” Proceedings of the National Academy of Sciences 116.1 (2019): 84-89.</p>
<p>[plasencia2020]: Plasencia, Diego Martinez, et al. “GS-PAT: high-speed multi-point sound-fields for phased arrays of transducers.” ACM Transactions on Graphics (TOG) 39.4 (2020): 138-1.</p>
<p>[levenberg1944]: Levenberg, Kenneth. “A method for the solution of certain non-linear problems in least squares.” Quarterly of applied mathematics 2.2 (1944): 164-168.</p>
<p>[marquardt1963]: Marquardt, Donald W. “An algorithm for least-squares estimation of nonlinear parameters.” Journal of the society for Industrial and Applied Mathematics 11.2 (1963): 431-441.</p>
<p>[madsen2004]: Madsen, Kaj, Hans Bruun Nielsen, and Ole Tingleff. “Methods for non-linear least squares problems.” (2004).</p>
<p>[hasegawa2020]: Hasegawa, Keisuke, Hiroyuki Shinoda, and Takaaki Nara. “Volumetric acoustic holography and its application to self-positioning by single channel measurement.” Journal of Applied Physics 127.24 (2020): 244904.</p>
<p>[suzuki2021]: Suzuki, Shun, et al. “Radiation Pressure Field Reconstruction for Ultrasound Midair Haptics by Greedy Algorithm with Brute-Force Search.” IEEE Transactions on Haptics (2021).</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="modulation"><a class="header" href="#modulation">Modulation</a></h1>
<p><code>Modulation</code> is a mechanism to control Amplitude Modulation.
The <code>Modulation</code> is realized by sampling <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span></span></span></span></span> data stored in a buffer in FPGA at a certain sampling rate and multiplying it by the duty ratio.
Currently, <code>Modulation</code> has the following limitations.</p>
<ul>
<li>Maximum buffer size is 65536.</li>
<li>Sampling rate is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span></span></span></span>.</li>
<li>Modulation is the same for all devices.</li>
<li>Modulation is automatically looped.</li>
</ul>
<p>The SDK provides <code>Modulation</code>s to generate several kinds of AM by default.</p>
<h2 id="static"><a class="header" href="#static">Static</a></h2>
<p>Without amplitude modulation.</p>
<pre><code class="language-cpp">  autd::modulation::Static m;
</code></pre>
<p>Note that the first argument can be a value of <code>uint8_t</code> (default is 255), which can be used to change the output of the ultrasound uniformly.</p>
<h2 id="sine"><a class="header" href="#sine">Sine</a></h2>
<p><code>Modulation</code> for deforming the sound pressure into a sine wave shape.</p>
<pre><code class="language-cpp">  autd::modulation::Sine m(f, amplitude, offset); 
</code></pre>
<p>The first argument is the frequency <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, the second argument is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> (1 by default), and the third argument is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> (0.5 by default), and the sound pressure waveform will be
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span>
Here, values out of<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> are clamped to fit in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>.
The sampling frequency is set to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span> (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>) by default.</p>
<h2 id="sinesquared"><a class="header" href="#sinesquared">SineSquared</a></h2>
<p><code>Modulation</code> for deforming the radiation pressure, i.e. the square of the sound pressure, into sine wave shape.
The arguments are the same as for <code>Sine</code>.</p>
<h2 id="sinelegacy"><a class="header" href="#sinelegacy">SineLegacy</a></h2>
<p>This <code>Modulation</code> is compatible with <code>Sine Modulation</code> in the old version.
The frequency can be a value of <code>double</code>, but it is not exactly the specified frequency, the closest frequency among the possible output frequencies is chosen.
Also, the duty ratio, not the sound pressure, becomes sine wave.</p>
<h2 id="square"><a class="header" href="#square">Square</a></h2>
<p>Square wave-shaped <code>Modulation</code>.</p>
<pre><code class="language-cpp">autd::modulation::Square m(f, low, high); 
</code></pre>
<p>The first argument is the frequency <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, the second argument is low level (0 by default), the third argument is high level (255 by default).
The duty ratio of the square modulation can be specified as the fourth argument.
The duty ratio of the square modulation is defined by <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">high</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">high</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">high</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> is the time to output high in a period <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</p>
<h2 id="lpf"><a class="header" href="#lpf">LPF</a></h2>
<p><code>LPF</code> takes another <code>Modulation</code> as argument, and apply Low-pass filter to the <code>Modulation</code> for suppress noise.</p>
<pre><code class="language-cpp">  autd::modulation::LPF lpf(m); 
</code></pre>
<h2 id="create-custom-modulation-tutorial"><a class="header" href="#create-custom-modulation-tutorial">Create Custom Modulation Tutorial</a></h2>
<p>You can create your own <code>Modulation</code>, as well as <code>Gain</code>.
Here, we try to make a <code>Burst</code> which outputs only for a moment in a cycle<sup class="footnote-reference"><a href="#fn_burst">1</a></sup>.</p>
<p>The following is a sample of <code>Burst</code>.</p>
<pre><code class="language-cpp">class Burst final : public autd::core::Modulation {
 public:
  void calc() override {
    this-&gt;_buffer.resize(_buf_size, 0);
    this-&gt;_buffer[_buf_size - 1] = 0xFF;
  }

  explicit Burst(const size_t buf_size = 4000, const uint16_t mod_freq_div = 10) : Modulation(mod_freq_div), _buf_size(buf_size) {}

 private:
  size_t _buf_size;
};
</code></pre>
<p>Like <code>Gain</code>, <code>Modulation</code> has a <code>Modulation::calc</code> method called in <code>Controller::send</code>.
So, in this <code>calc</code>, you should rewrite the contents of <code>buffer</code>.
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, which determines the <code>Modulation</code> sampling frequency <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, is specified as the first argument of the constructor of <code>Modulation</code>.
In this example, the default value is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>, so the sampling frequency is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span>.
Furthermore, for example, if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">buf_size</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>, the AM value <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> will be sampled <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span></span></span></span> times and then <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span> once.
Thus, the AM such that outputs only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">s</span></span></span></span></span></span> in the period <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">s</span></span></span></span></span></span> will be applied.</p>
<h2 id="modulation-common-functions"><a class="header" href="#modulation-common-functions">Modulation common functions</a></h2>
<h3 id="sampling_freq_div_ratio"><a class="header" href="#sampling_freq_div_ratio">sampling_freq_div_ratio</a></h3>
<p>You can use <code>sampling_freq_div_ratio</code> function to check and set the sampling frequency division ratio <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>.
The base frequency of sampling frequency is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span>.
The <code>sampling_freq_div_ratio</code> can be any integer between 1 and 65536.</p>
<pre><code class="language-cpp">    m.sampling_freq_div_ratio() = 5; // 40kHz/5 = 8kHz
</code></pre>
<h3 id="sampling_freq"><a class="header" href="#sampling_freq">sampling_freq</a></h3>
<p>You can get the sampling frequency by <code>sampling_freq</code>.</p>
<div class="footnote-definition" id="fn_burst"><sup class="footnote-definition-label">1</sup>
<p>This <code>Burst</code> Modulation does not exists in SDK.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="sequence"><a class="header" href="#sequence">Sequence</a></h1>
<p>SDK provides functions to switch <code>Gain</code> periodically.
These functions are classified into <code>stm</code> and <code>Sequence</code>.
In the <code>stm</code>, any <code>Gain</code> can be used as long as the memory of the host is available, but the time precision is low because it is executed by a software timer.
The latter is executed by a hardware timer and has high accuracy but has a strong restriction.</p>
<h2 id="stm"><a class="header" href="#stm">stm</a></h2>
<p>The following is a sample of moving a single focus periodically on the circumference using <code>stm</code>.</p>
<pre><code class="language-cpp">  auto autd = autd::Controller::create();
  
  ...
  
  const auto stm = autd.stm();

  const autd::Vector3 center(x, y, z);
  constexpr auto point_num = 100;
  for (auto i = 0; i &lt; point_num; i++) {
    constexpr auto radius = 20.0;
    const auto theta = 2.0 * M_PI * static_cast&lt;double&gt;(i) / point_num;
    const autd::Vector3 pos(radius * cos(theta), radius * sin(theta), 0.0);
    autd::gain::FocalPoint g(center + pos);
    stm &lt;&lt; g;
  }

  stm.start(0.5);  // 0.5 Hz

  std::cout &lt;&lt; &quot;press any key to stop...&quot; &lt;&lt; std::endl;
  std::cin.ignore();

  stm.stop();
  stm.finish();
</code></pre>
<p>In the above example, 100 points are sampled at equal intervals on a circle of radius <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">m</span></span></span></span></span></span> whose center is at <code>center</code>.
A focus moves on the circle while leaping from a sampled point to another at a frequency of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span>.</p>
<p>To use <code>stm</code>, get a controller for <code>stm</code> with <code>Controller::stm</code>.
Then, add <code>Gain</code> to this <code>stm</code> controller with <code>add_gain</code>.
And, start the <code>stm</code> with the <code>start</code> function.
If you want to pause the <code>stm</code>, call the <code>stop</code> function.
To resume, call <code>start</code> again after <code>stop</code>.
Finally, call the <code>finish</code> function to finish <code>stm</code>.</p>
<p>The use of the original <code>Controller</code> is prohibited between the acquisition of the <code>stm</code> controller and the call to <code>finish</code>.</p>
<h2 id="sequence-1"><a class="header" href="#sequence-1">Sequence</a></h2>
<p><code>Sequence</code> realizes Spatio-Temporal Modulation with a hardware timer.
SDK provides <code>PointSequence</code> which supports only a single focus moving, and <code>GainSequence</code> which supports arbitrary <code>Gain</code> moving.</p>
<h3 id="pointsequence"><a class="header" href="#pointsequence">PointSequence</a></h3>
<p><code>PointSequence</code> has the following restrictions.</p>
<ul>
<li>Maximum sampling point is 65536.</li>
<li>Sampling frequency is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span></span></span></span></li>
</ul>
<p>The usage of <code>PointSequence</code> is almost the same as that of <code>stm</code>.</p>
<pre><code class="language-cpp">  autd::sequence::PointSequence seq;

  const autd::Vector3 center(x, y, z);
  constexpr auto point_num = 200;
  for (auto i = 0; i &lt; point_num; i++) {
    constexpr auto radius = 30.0;
    const auto theta = 2.0 * M_PI * static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(point_num);
    const autd::Vector3 p(radius * std::cos(theta), radius * std::sin(theta), 0);
    seq &lt;&lt; center + p;
  }

  const auto actual_freq = seq.set_frequency(1);
  std::cout &lt;&lt; &quot;Actual frequency is &quot; &lt;&lt; actual_freq &lt;&lt; &quot; Hz\n&quot;;
  autd &lt;&lt; seq;
</code></pre>
<p>Due to the constraints on the number of sampling points and sampling period, the specified frequency and the actual frequency may differ.
For example, in the above example, since <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> points are sampled and frequency is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span>, the sampling frequency should be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span><span class="mord">/</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span>, which satisfies the constraint.
However, for example, if <code>point_num</code>=199, the sampling frequency must be <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord">9</span><span class="mord">9</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span>, but there is no <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">5</span></span></span></span> such that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mord">9</span><span class="mord">9</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is satisfied. 
Therefore, the nearest <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> will be selected. 
This causes a shift between the specified frequency and the actual frequency.
The <code>set_frequency</code> function returns the actual frequency.</p>
<h3 id="gainsequence"><a class="header" href="#gainsequence">GainSequence</a></h3>
<p><code>GainSequence</code> can handle any <code>Gain</code>, but the number of <code>Gain</code>s is reduced to 2048 instead.</p>
<p>The usage of <code>GainSequence</code> is almost the same as that of <code>PointSequence</code>.</p>
<pre><code class="language-cpp">  autd::GainSequence seq(autd.geometry());

  const autd::Vector3 center(x, y, z);
  constexpr auto point_num = 200;
  for (auto i = 0; i &lt; point_num; i++) {
    constexpr auto radius = 30.0;
    const auto theta = 2.0 * M_PI * static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(point_num);
    const autd::Vector3 p(radius * std::cos(theta), radius * std::sin(theta), 0);
    autd::gain::FocalPoint g(center + p);
    seq &lt;&lt; g;
  }

  const auto actual_freq = seq.set_frequency(1);
  std::cout &lt;&lt; &quot;Actual frequency is &quot; &lt;&lt; actual_freq &lt;&lt; &quot; Hz\n&quot;;
  autd &lt;&lt; seq;
</code></pre>
<p>The frequency constraint is also the same as for <code>PointSequence</code>.</p>
<p>Since <code>GainSequence</code> sends all phase/amplitude data, the latency is large<sup class="footnote-reference"><a href="#fn_gain_seq">1</a></sup>.
To reduce the latency, <code>GainSequence</code> provides additional two modes: <code>PHASE_FULL</code> mode which sends only phase data, and <code>PHASE_HALF</code> mode which sends only phase data compressed to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span></span></span></span></span>.
These modes are switched by the first argument of <code>GainSequence::create()</code>.
The type of the first argument is <code>GAIN_MODE</code>, and the following values are provided.</p>
<ul>
<li><code>DUTY_PHASE_FULL</code> - Send phase/amplitude, default</li>
<li><code>PHASE_FULL</code> - Send only phase. This mode has half latency against for <code>DUTY_PHASE_FULL</code></li>
<li><code>PHASE_HALF</code> - Send only phase compressed to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span></span></span></span></span>. This mode has quarter latency against for <code>DUTY_PHASE_FULL</code></li>
</ul>
<h3 id="sequence-common-functions"><a class="header" href="#sequence-common-functions">Sequence common functions</a></h3>
<h4 id="frequency"><a class="header" href="#frequency">frequency</a></h4>
<p>Get frequency of <code>Sequence</code></p>
<h4 id="period_us"><a class="header" href="#period_us">period_us</a></h4>
<p>Get cycle of <code>Sequence</code> in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="mord mathrm">s</span></span></span></span></span></span></p>
<h4 id="sampling_freq-1"><a class="header" href="#sampling_freq-1">sampling_freq</a></h4>
<p>Get sampling frequency of <code>Sequence</code></p>
<h4 id="sampling_period_us"><a class="header" href="#sampling_period_us">sampling_period_us</a></h4>
<p>Get sampling cycle of <code>Sequence</code> in <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="mord mathrm">s</span></span></span></span></span></span></p>
<h4 id="sampling_freq_div_ratio-1"><a class="header" href="#sampling_freq_div_ratio-1">sampling_freq_div_ratio</a></h4>
<p>Get and set the sampling frequency division ratio of <code>Sequence</code>.
The base frequency of sampling frequency is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">k</span><span class="mord mathrm">H</span><span class="mord mathrm">z</span></span></span></span></span></span>.
The <code>sampling_freq_div_ratio</code> can be an integer from 1 to 65536.</p>
<pre><code class="language-cpp">    seq.sampling_freq_div_ratio() = 5; // 40kHz/5 = 8kHz
</code></pre>
<div class="footnote-definition" id="fn_gain_seq"><sup class="footnote-definition-label">1</sup>
<p>Approximately 60x latency against for <code>PointSequence</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="controller"><a class="header" href="#controller">Controller</a></h1>
<p>In this section, we introduce some other functions of the Controller class.</p>
<h2 id="output-enable"><a class="header" href="#output-enable">Output enable</a></h2>
<p>Configure the output enable settings.</p>
<pre><code class="language-cpp">  autd.output_enable() = false;
</code></pre>
<p>The output of the FPGA is the logical product of this flag.</p>
<p>The flag will be actually updated after calling one of the <a href="Software/Users_Manual/controller.html#send-functions">Send functions</a>.</p>
<h2 id="silent-mode"><a class="header" href="#silent-mode">Silent mode</a></h2>
<p>In AM and Spatio-Temporal Modulation, noise is generated while the phase/amplitude changes abruptly.
SDK provides a flag to suppress this noise.</p>
<pre><code class="language-cpp">  autd.silent_mode() = true;
</code></pre>
<p>When this flag is set to on, a low-pass filter is applied to the phase/amplitude data inside the device, smoothing the phase/amplitude changes and suppressing noise [suzuki2020].</p>
<p>The flag will be actually updated after calling one of the <a href="Software/Users_Manual/controller.html#send-functions">Send functions</a>.</p>
<h2 id="check-ack"><a class="header" href="#check-ack">Check Ack</a></h2>
<p>If the <code>check_ack</code> flag is set to on, when sending data to the device, SDK will check whether the sent data has been processed by the device or not.</p>
<pre><code class="language-cpp">  autd.check_ack() = true;
</code></pre>
<p>If <code>check_ack</code> is <code>true</code>, functions that send data to the device (<a href="Software/Users_Manual/controller.html#send-functions">Send functions</a>) will return whether the sent data has been properly processed by the device or not.</p>
<p>Basically, you have no problem with this flag off, but if you want to send data certainly, turn this flag on.
Note that the execution time of <a href="Software/Users_Manual/controller.html#send-functions">Send functions</a> will increase if you turn this flag on.</p>
<h2 id="force-fan"><a class="header" href="#force-fan">Force fan</a></h2>
<p>AUTD3 devices are equipped with a thermal sensor, which automatically starts a fan when the temperature becomes too high.
The <code>force_fan</code> flag is a flag to force the fan to start.</p>
<p>The flag will be actually updated after calling one of the <a href="Software/Users_Manual/controller.html#send-functions">Send functions</a>.</p>
<pre><code class="language-cpp">  autd.force_fan() = true;
</code></pre>
<p>Note that the fan can be forced on, but it cannot be forced off.</p>
<h2 id="read-fpga-info"><a class="header" href="#read-fpga-info">Read FPGA info</a></h2>
<p>If you turn on the <code>reads_fpga_info</code> flag, the device will return the FPGA status.</p>
<p>The flag will be actually updated after calling one of the <a href="Software/Users_Manual/controller.html#send-functions">Send functions</a>.</p>
<p>The status of the FPGA can be obtained with the <code>fpga_info</code> function.</p>
<pre><code class="language-cpp">  autd.reads_fpga_info() = true;
  autd.update_ctrl_flag();
  const auto fpga_info = autd.fpga_info();
</code></pre>
<p>The return value of <code>fpga_info</code> is a <code>vector</code> of <code>FPGAInfo</code>.</p>
<h2 id="duty-offset"><a class="header" href="#duty-offset">Duty offset</a></h2>
<p>To change <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">offset</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (see <a href="Software/Users_Manual/gain.html#create-custom-gain-tutorial">Create Custom Gain Tutorial</a>), send <code>DelayOffsets</code> struct.
Note that only the lowest <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span></span></span></span></span> is used, so only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">offset</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span></span></span></span> can be used.</p>
<pre><code class="language-cpp">  autd::DelayOffsets delay_offsets(autd.geometry().num_devices());

  delay_offsets[0].offset = 0;  // duty offset is 0 for 0-th transducer 
  autd &lt;&lt; delay_offsets;       // apply change
</code></pre>
<h2 id="output-delay"><a class="header" href="#output-delay">Output delay</a></h2>
<p>SDK provides a function to delay the output of each transducer relative to the unit of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="mord">5</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="mord mathrm">s</span></span></span></span></span></span>.
To do so, use the <code>output_delay</code> function.
Note that only the lower <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">7</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">b</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span></span></span></span></span></span> of the delay value is used, and so the maximum delay is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">7</span><span class="mord">5</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">s</span></span></span></span></span></span>.</p>
<pre><code class="language-cpp">  autd::DelayOffsets delay_offsets(autd.geometry().num_devices());

  delay_offsets[0].delay = 4;  // 4 cycle = 100 us delay in 0-th transducer
  autd &lt;&lt; delay_offsets;       // apply change
</code></pre>
<h2 id="pauseresumestop"><a class="header" href="#pauseresumestop">pause/resume/stop</a></h2>
<p>Call the <code>pause</code> function to pause the output.
It can be resumed with the <code>resume</code> function.</p>
<p>The <code>stop</code> function also stops the output, but cannot be resumed by <code>resume</code>.</p>
<p>Because the <code>pause</code> function stops the output abruptly (specifically, it takes the logical product of the output from the FPGA with 0), it may cause shutdown noise.
The <code>stop</code> function is designed to suppress it.</p>
<h2 id="clear"><a class="header" href="#clear">clear</a></h2>
<p>Clear the flags, <code>Gain</code>/<code>Modulation</code> data, etc. in the device.</p>
<h2 id="firmware-information"><a class="header" href="#firmware-information">Firmware information</a></h2>
<p>The <code>firmware_info_list</code> function can be used to get the version information of firmware.</p>
<pre><code class="language-cpp"> for (auto&amp;&amp; firm_info : autd.firmware_info_list()) std::cout &lt;&lt; firm_info &lt;&lt; std::endl;
</code></pre>
<h2 id="send-functions"><a class="header" href="#send-functions">Send functions</a></h2>
<p>Send functions is a generic term for functions that actually send data to the device.
By calling these functions, the flags <code>output enable</code>, <code>silent mode</code>, <code>force fan</code>, <code>reads FPGA info</code>, and <code>output balance</code> are updated.
The behavior of these functions depends on the <code>check_ack</code> flag.
If <code>check_ack</code> is <code>true</code>, these functions will wait until the device actually processes the data, and return a bool value which represents whether the sending is succeeded.
Especially, when sending <code>Modulation</code>/<code>Sequence</code>, the processing time may increase significantly because the check is done every frame.
If <code>check_ack</code> is <code>false</code>, it does not check whether the data has been processed or not, and the return value is always <code>true</code>.</p>
<p>The following is a list of Send functions.</p>
<ul>
<li><code>update_ctrl_flag</code></li>
<li><code>clear</code></li>
<li><code>close</code></li>
<li><code>stop</code></li>
<li><code>pause</code></li>
<li><code>resume</code></li>
<li><code>send</code></li>
<li><code>&lt;&lt;</code> (stream input operator)</li>
</ul>
<p>[suzuki2020]: Suzuki, Shun, et al. “Reducing amplitude fluctuation by gradual phase shift in midair ultrasound haptics.” IEEE transactions on haptics 13.1 (2020): 87-93.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ffi"><a class="header" href="#ffi">FFI</a></h1>
<p>Currently, the following languages are supported in addition to C++.</p>
<ul>
<li><a href="Software/FFI/./csharp.html">C#</a></li>
<li><a href="Software/FFI/./python.html">python</a></li>
<li><a href="Software/FFI/./julia.html">Julia</a></li>
<li><a href="Software/FFI/./rust.html">Rust</a></li>
</ul>
<p>The C API reference that can be used with other languages is written as follows.</p>
<ul>
<li><a href="Software/FFI/./reference.html">C API Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="c"><a class="header" href="#c">C#</a></h1>
<p><a href="https://github.com/shinolab/autd3sharp">autd3sharp</a> provides a wrapper for <strong>.Net Standard 2.1</strong>.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>It is available at <a href="https://www.nuget.org/packages/autd3sharp">NuGet</a>, and you can install it from NuGet.</p>
<h3 id="installation-for-unity"><a class="header" href="#installation-for-unity">Installation for Unity</a></h3>
<p>If you want to use it from Unity, please use <em>unitypackage</em> which is available at <a href="https://github.com/shinolab/autd3sharp/releases">GitHub Release</a>.</p>
<p>After installing this package, go to <code>Project Settings &gt; Player</code> and check <code>Allow 'unsafe' code</code>. 
Also, to suppress warnings, add <code>-nullable:enable</code> to <code>Additional Compiler Arguments</code>.</p>
<p><strong>Note that the Unity version has a left-handed coordinate system with z-axis reversed, and the unit of distance is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">m</span></span></span></span></span></span>.</strong></p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Basically, it is designed to be the same as the C++ version.</p>
<p>For example, the equivalent code of <a href="Software/FFI/./Users_Manual/getting_started.html">Getting Started</a> is the following.</p>
<pre><code class="language-csharp">using AUTD3Sharp;
using AUTD3Sharp.Utils;

namespace example
{
    internal class Program
    {
        public static string GetIfname()
        {
            var adapters = AUTD.EnumerateAdapters();
            var etherCATAdapters = adapters as EtherCATAdapter[] ?? adapters.ToArray();
            foreach (var (adapter, index) in etherCATAdapters.Select((adapter, index) =&gt; (adapter, index)))
                Console.WriteLine($&quot;[{index}]: {adapter}&quot;);

            Console.Write(&quot;Choose number: &quot;);
            int i;
            while (!int.TryParse(Console.ReadLine(), out i)) { }
            return etherCATAdapters.ElementAt(i).Name;
        }

        public static void Main()
        {
            var autd = new AUTD();
            autd.AddDevice(Vector3d.Zero, Vector3d.Zero);

            var ifname = GetIfname();
            var link = Link.SOEM(ifname, autd.NumDevices);
            if (!autd.Open(link))
            {
                Console.WriteLine(AUTD.LastError);
                return;
            }

            autd.Clear();

            var firmList = autd.FirmwareInfoList().ToArray();
            foreach (var (firm, index) in firmList.Select((firm, i) =&gt; (firm, i)))
                Console.WriteLine($&quot;AUTD {index}: {firm}&quot;);

            autd.SilentMode = false;

            const double x = AUTD.TransSpacing * ((AUTD.NumTransInX - 1) / 2.0);
            const double y = AUTD.TransSpacing * ((AUTD.NumTransInY - 1) / 2.0);
            const double z = 150.0;
            var g = Gain.FocalPoint(new Vector3d(x, y, z));
            var m = Modulation.Sine(150);
            autd.Send(g, m);

            Console.ReadKey(true);

            autd.Close();
        }
    }
}
</code></pre>
<p>For a more detailed example, see <a href="https://github.com/shinolab/autd3sharp/tree/master/example">autd3sharp’s example</a>.</p>
<h2 id="trouble-shooting-1"><a class="header" href="#trouble-shooting-1">Trouble shooting</a></h2>
<p>Q. Cannot run from linux or macOS</p>
<p>A. Run as root</p>
<pre><code>sudo dotnet run
</code></pre>
<hr />
<p>Q. Cannot run from Ubuntu 20.04</p>
<p>A. Specify runtime</p>
<pre><code>sudo dotnet run -r ubuntu-x64
</code></pre>
<hr />
<p>Q. Cannot be used from .Net framework</p>
<p>A. .Net framework is not supported. If you copy and paste the whole source code, it may work.</p>
<hr />
<p>If you have any other questions, please send them to <a href="https://github.com/shinolab/autd3sharp/issues">GitHub issues</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="python"><a class="header" href="#python">python</a></h1>
<p><a href="https://github.com/shinolab/pyautd">pyautd</a> provides a wrapper for python 3.7+.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>It is available at <a href="https://pypi.org/project/pyautd3">PyPI</a>, and you can install it from pip.</p>
<pre><code>pip install pyautd3
</code></pre>
<p>Alternatively, you can install it from the pyautd repository.</p>
<pre><code>pip install git+https://github.com/shinolab/pyautd.git
</code></pre>
<h3 id="linuxmacos"><a class="header" href="#linuxmacos">Linux/macOS</a></h3>
<p>If you are using Linux/macOS, you may need administrator privileges. 
In that case, install pyautd with administrative privileges.</p>
<pre><code>sudo pip install pyautd3
</code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Basically, it is designed to be the same as the C++ version.</p>
<p>For example, the equivalent code of <a href="Software/FFI/./Users_Manual/getting_started.html">Getting Started</a> is the following.</p>
<pre><code class="language-python">from pyautd3 import AUTD, Link, Gain, Modulation, TRANS_SPACING_MM, NUM_TRANS_X, NUM_TRANS_Y


def get_adapter_name():
    adapters = Link.enumerate_adapters()
    for i, adapter in enumerate(adapters):
        print('[' + str(i) + ']: ' + adapter[0] + ', ' + adapter[1])

    index = int(input('choose number: '))
    return adapters[index][0]


if __name__ == '__main__':
    autd = AUTD()

    autd.add_device([0., 0., 0.], [0., 0., 0.])

    ifname = get_adapter_name()
    link = Link.soem(ifname, autd.num_devices())
    if not autd.open(link):
        print(AUTD.last_error())
        exit()

    autd.clear()

    firm_info_list = autd.firmware_info_list()
    for i, firm in enumerate(firm_info_list):
        print(f'[{i}]: CPU: {firm[0]}, FPGA: {firm[1]}')

    autd.silent_mode = True

    x = TRANS_SPACING_MM * ((NUM_TRANS_X - 1) / 2.0)
    y = TRANS_SPACING_MM * ((NUM_TRANS_Y - 1) / 2.0)
    z = 150.0
    g = Gain.focal_point([x, y, z])
    m = Modulation.sine(150)
    autd.send(g, m)

    _ = input()

    autd.close()
</code></pre>
<p>For a more detailed example, see <a href="https://github.com/shinolab/pyautd/tree/master/example">pyautd’s example</a>.</p>
<h2 id="trouble-shooting-2"><a class="header" href="#trouble-shooting-2">Trouble shooting</a></h2>
<p>Q. Cannot run from linux or macOS</p>
<p>A. Run as root</p>
<pre><code>sudo python
</code></pre>
<p>If you have any other questions, please send them to <a href="https://github.com/shinolab/pyautd/issues">GitHub issues</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="julia"><a class="header" href="#julia">Julia</a></h1>
<p><a href="https://github.com/shinolab/AUTD3.jl">AUTD3.jl</a> provides a wrapper for Julia.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>You can install AUTD3.jl via package manager.</p>
<pre><code>(v1.7) pkg&gt; add https://github.com/shinolab/AUTD3.jl.git
</code></pre>
<h3 id="linuxmacos-1"><a class="header" href="#linuxmacos-1">Linux/macOS</a></h3>
<p>If you are using Linux/macOS, you may need administrator privileges. 
In that case, install AUTD3.jl with administrative privileges.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>Basically, it is designed to be the same as the C++ version.</p>
<p>For example, the equivalent code of <a href="Software/FFI/./Users_Manual/getting_started.html">Getting Started</a> is the following.</p>
<pre><code class="language-julia">using Printf

using AUTD3
using StaticArrays
using StaticArrays:size

function get_adapter()
    adapters = enumerate_adapters();
    for (i, adapter) in enumerate(adapters)
        @printf(&quot;[%d]: %s, %s\n&quot;, i, adapter[2], adapter[1])
    end

    print(&quot;Input number: &quot;)
    idx = tryparse(Int64, readline())
    if idx === nothing || idx &gt; length(adapters) || idx &lt; 1
        println(&quot;choose correct number!&quot;)
        return &quot;&quot;
    end

    adapters[idx][2]
end

function main()
    autd = AUTD()

    add_device(autd, SVector(0., 0., 0.), SVector(0., 0., 0.))

    adapter = get_adapter()
    link = soem_link(adapter, num_devices(autd))
    if !open_autd(autd, link)
        println(last_error())
        return
    end

    clear(autd)

    firm_info_list = firmware_info_list(autd)
    for (i, firm_info) in enumerate(firm_info_list)
        @printf(&quot;AUTD[%d]: CPU: %s, FPGA: %s\n&quot;, i, firm_info[1], firm_info[2])
    end

    set_silent_mode(autd, true)

    x = TRANS_SPACING_MM * ((NUM_TRANS_X - 1) / 2.0)
    y = TRANS_SPACING_MM * ((NUM_TRANS_Y - 1) / 2.0)
    z = 150.0
    g = focal_point_gain(SVector(x, y, z))
    freq::Int32 = 150
    m = sine_modulation(freq)

    send(autd, g, m)

    readline()

    dispose(g)
    dispose(m)
    dispose(autd)
end

main()
</code></pre>
<p>For a more detailed example, see <a href="https://github.com/shinolab/AUTD3.jl/tree/master/example">AUTD3.jl’s example</a>.</p>
<h2 id="trouble-shooting-3"><a class="header" href="#trouble-shooting-3">Trouble shooting</a></h2>
<p>Q. Cannot run from linux or macOS</p>
<p>A. Run as root</p>
<pre><code>sudo julia
</code></pre>
<p>If you have any other questions, please send them to <a href="https://github.com/shinolab/AUTD3.jl/issues">GitHub issues</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Rust version of SDK is available at <a href="https://github.com/shinolab/rust-autd">rust-autd</a>.</p>
<p>This rust version is not a wrapping of the C++ version, but a re-implementation in rust.
Therefore, some functions may be different from C++ SDK.</p>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<p>rust-autd is available at <a href="https://crates.io/crates/autd3">crate.io</a>.</p>
<pre><code>[dependencies]
autd3 = &quot;1.10.0&quot;
</code></pre>
<p>links, gains, etc. are published as separate crates, so please add them to dependencies if necessary.</p>
<pre><code>[dependencies]
autd3-soem-link = &quot;1.10.0&quot;
autd3-twincat-link = &quot;1.10.0&quot;
autd3-emulator-link = &quot;1.10.0&quot;
autd3-holo-gain = &quot;1.10.0&quot;
</code></pre>
<p>In addition, an asynchronous runtime is required. 
In the following example, we use tokio.</p>
<pre><code>[dependencies]
tokio = { version = &quot;1.6.1&quot;, features = [&quot;rt&quot;, &quot;time&quot;, &quot;rt-multi-thread&quot;]}
</code></pre>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<p>Basically, it is designed to be the same as the C++ version.</p>
<p>For example, the equivalent code of <a href="Software/FFI/./Users_Manual/getting_started.html">Getting Started</a> is the following.</p>
<pre><pre class="playground"><code class="language-rust">use autd3::prelude::*;
use autd3_soem_link::{EthernetAdapters, SoemLink};
use std::io::{self, Write};

fn get_adapter() -&gt; String {
    let adapters: EthernetAdapters = Default::default();
    for (index, adapter) in adapters.into_iter().enumerate() {
        println!(&quot;[{}]: {}&quot;, index, adapter);
    }

    let i: usize;
    let mut s = String::new();
    loop {
        print!(&quot;Choose number: &quot;);
        io::stdout().flush().unwrap();

        io::stdin().read_line(&amp;mut s).unwrap();
        match s.trim().parse() {
            Ok(num) if num &lt; adapters.len() =&gt; {
                i = num;
                break;
            }
            _ =&gt; continue,
        };
    }
    let adapter = &amp;adapters[i];
    adapter.name.to_string()
}

async fn main_task() {
    let mut geometry = Geometry::new();
    geometry.add_device(Vector3::zeros(), Vector3::zeros());

    let ifname = get_adapter();
    let link = SoemLink::new(&amp;ifname, geometry.num_devices() as u16, 1, |msg| {
        eprintln!(&quot;unrecoverable error occurred: {}&quot;, msg);
        std::process::exit(-1);
    });

    let mut autd = Controller::open(geometry, link).expect(&quot;Failed to open&quot;);

    autd.clear().await.unwrap();

    println!(&quot;***** Firmware information *****&quot;);
    let firm_list = autd.firmware_infos().await.unwrap();
    for firm_info in firm_list {
        println!(&quot;{}&quot;, firm_info);
    }
    println!(&quot;********************************&quot;);

    autd.silent_mode = true;

    let center = Vector3::new(
        TRANS_SPACING_MM * ((NUM_TRANS_X - 1) as f64 / 2.0),
        TRANS_SPACING_MM * ((NUM_TRANS_Y - 1) as f64 / 2.0),
        150.0,
    );
    let mut g = Focus::new(center);
    let mut m = Sine::new(150);
    autd.send(&amp;mut m, &amp;mut g).await.unwrap();

    let mut _s = String::new();
    io::stdin().read_line(&amp;mut _s).unwrap();

    autd.close().await.unwrap();
}

fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async { main_task().await });
}
</code></pre></pre>
<p>For a more detailed example, see <a href="https://github.com/shinolab/rust-autd/tree/master/autd3-examples">rust-autd’s example</a>.</p>
<h2 id="trouble-shooting-4"><a class="header" href="#trouble-shooting-4">Trouble shooting</a></h2>
<p>If you have any other questions, please send them to <a href="https://github.com/shinolab/rust-autd/issues">GitHub issues</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>The API for the C language is defined under <a href="https://github.com/shinolab/autd3-library-software/tree/master/client/capi">client/capi</a>.
The reference of this API is given below. 
For actual usage, see <a href="https://github.com/shinolab/autd3-library-software/tree/master/client/capi/example">C API examples</a>, <a href="https://github.com/shinolab/autd3sharp">C#</a>/<a href="https://github.com/shinolab/pyautd">python</a>/<a href="https://github.com/shinolab/AUTD3.jl">Julia</a> wrapper libraries.</p>
<blockquote>
<p>Note: The calling conventions are not explicitly stated. The x86 conventions are probably <code>cdecl</code>, but we haven’t checked it yet, and it may cause errors when used from x86.</p>
</blockquote>
<h2 id="autdcreatecontroller-autd3capi"><a class="header" href="#autdcreatecontroller-autd3capi">AUTDCreateController (autd3capi)</a></h2>
<p>Create <code>Controller</code>.</p>
<p>You need to release the <code>Controller</code> you created with <code>AUTDFreeController</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to ControllerPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdopencontroller-autd3capi"><a class="header" href="#autdopencontroller-autd3capi">AUTDOpenController (autd3capi)</a></h2>
<p>Open <code>Controller</code>. 
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This function returns false if fails.
If it returns false, you can get the error message with <code>AUTDGetLastError</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>link</td><td>void*</td><td>in</td><td>LinkPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if success</td></tr>
</tbody></table>
<h2 id="autdadddevice-autd3capi"><a class="header" href="#autdadddevice-autd3capi">AUTDAddDevice (autd3capi)</a></h2>
<p>Add device to <code>Controller</code>.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>. 
(x, y, z) are the positions, and (rz1, ry, rz2) are the ZYZ euler angles.</p>
<p>This function returns the ID of the added device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>x</td><td>double</td><td>in</td><td>x coordinate of position in millimeter</td></tr>
<tr><td>y</td><td>double</td><td>in</td><td>y coordinate of position in millimeter</td></tr>
<tr><td>z</td><td>double</td><td>in</td><td>z coordinate of position in millimeter</td></tr>
<tr><td>rz1</td><td>double</td><td>in</td><td>first angle of ZYZ euler angle in radian</td></tr>
<tr><td>ry</td><td>double</td><td>in</td><td>second angle of ZYZ euler angle in radian</td></tr>
<tr><td>rz2</td><td>double</td><td>in</td><td>third angle of ZYZ euler angle in radian</td></tr>
<tr><td>gid</td><td>int32_t</td><td>in</td><td>group Id</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>Device Id</td></tr>
</tbody></table>
<h2 id="autdadddevicequaternion-autd3capi"><a class="header" href="#autdadddevicequaternion-autd3capi">AUTDAddDeviceQuaternion (autd3capi)</a></h2>
<p>Add device to <code>Controller</code>.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.
(x, y, z) are the positions, and (qw, qx, qy, qz) are the quaternion.</p>
<p>This function returns the ID of the added device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>x</td><td>double</td><td>in</td><td>x coordinate of position in millimeter</td></tr>
<tr><td>y</td><td>double</td><td>in</td><td>y coordinate of position in millimeter</td></tr>
<tr><td>z</td><td>double</td><td>in</td><td>z coordinate of position in millimeter</td></tr>
<tr><td>qw</td><td>double</td><td>in</td><td>quaternion of rotation</td></tr>
<tr><td>qx</td><td>double</td><td>in</td><td>quaternion of rotation</td></tr>
<tr><td>qy</td><td>double</td><td>in</td><td>quaternion of rotation</td></tr>
<tr><td>qz</td><td>double</td><td>in</td><td>quaternion of rotation</td></tr>
<tr><td>gid</td><td>int32_t</td><td>in</td><td>group Id</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>Device Id</td></tr>
</tbody></table>
<h2 id="autdclosecontroller-autd3capi"><a class="header" href="#autdclosecontroller-autd3capi">AUTDCloseController (autd3capi)</a></h2>
<p>Close Controller.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdclear-autd3capi"><a class="header" href="#autdclear-autd3capi">AUTDClear (autd3capi)</a></h2>
<p>Clear Controller.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdfreecontroller-autd3capi"><a class="header" href="#autdfreecontroller-autd3capi">AUTDFreeController (autd3capi)</a></h2>
<p>Delete Controller.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.
Never use <code>handle</code> after calling this function. </p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdisopen-autd3capi"><a class="header" href="#autdisopen-autd3capi">AUTDIsOpen (autd3capi)</a></h2>
<p>Returns whether Controller is open or not.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if controller is open</td></tr>
</tbody></table>
<h2 id="autdgetoutputenable-autd3capi"><a class="header" href="#autdgetoutputenable-autd3capi">AUTDGetOutputEnable (autd3capi)</a></h2>
<p>Returns Output enable flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>output enable flag</td></tr>
</tbody></table>
<h2 id="autdgetsilentmode-autd3capi"><a class="header" href="#autdgetsilentmode-autd3capi">AUTDGetSilentMode (autd3capi)</a></h2>
<p>Returns silent mode flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>silent mode flag</td></tr>
</tbody></table>
<h2 id="autdgetforcefan-autd3capi"><a class="header" href="#autdgetforcefan-autd3capi">AUTDGetForceFan (autd3capi)</a></h2>
<p>Returns Force fan flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>Force fan flag</td></tr>
</tbody></table>
<h2 id="autdgetreadsfpgainfo-autd3capi"><a class="header" href="#autdgetreadsfpgainfo-autd3capi">AUTDGetReadsFPGAInfo (autd3capi)</a></h2>
<p>Returns reads FPGA Info flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>reads FPGA Info flag</td></tr>
</tbody></table>
<h2 id="autdgetoutputbalance-autd3capi"><a class="header" href="#autdgetoutputbalance-autd3capi">AUTDGetOutputBalance (autd3capi)</a></h2>
<p>Returns Output balance flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>Output balance flag</td></tr>
</tbody></table>
<h2 id="autdgetcheckack-autd3capi"><a class="header" href="#autdgetcheckack-autd3capi">AUTDGetCheckAck (autd3capi)</a></h2>
<p>Returns check ack flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>Check ack flag</td></tr>
</tbody></table>
<h2 id="autdsetoutputenable-autd3capi"><a class="header" href="#autdsetoutputenable-autd3capi">AUTDSetOutputEnable (autd3capi)</a></h2>
<p>Set Output enable flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This flag will be updated in the device after calling one of the send functions.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>enable</td><td>bool</td><td>in</td><td>output enable flag</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsetsilentmode-autd3capi"><a class="header" href="#autdsetsilentmode-autd3capi">AUTDSetSilentMode (autd3capi)</a></h2>
<p>Set silent mode flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This flag will be updated in the device after calling one of the send functions.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>mode</td><td>bool</td><td>in</td><td>silent mode flag</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsetreadsfpgainfo-autd3capi"><a class="header" href="#autdsetreadsfpgainfo-autd3capi">AUTDSetReadsFPGAInfo (autd3capi)</a></h2>
<p>Set reads FPGA Info flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This flag will be updated in the device after calling one of the send functions.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>reads_fpga_info</td><td>bool</td><td>in</td><td>read FPGA info flag</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsetforcefan-autd3capi"><a class="header" href="#autdsetforcefan-autd3capi">AUTDSetForceFan (autd3capi)</a></h2>
<p>Set Force fan flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This flag will be updated in the device after calling one of the send functions.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>force</td><td>bool</td><td>in</td><td>force fan flag</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsetoutputbalance-autd3capi"><a class="header" href="#autdsetoutputbalance-autd3capi">AUTDSetOutputBalance (autd3capi)</a></h2>
<p>Set Output balance flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This flag will be updated in the device after calling one of the send functions.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>output_balance</td><td>bool</td><td>in</td><td>Output balance flag</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsetcheckack-autd3capi"><a class="header" href="#autdsetcheckack-autd3capi">AUTDSetCheckAck (autd3capi)</a></h2>
<p>Set Check ack flag.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>check_ack</td><td>bool</td><td>in</td><td>Check ack flag</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgetwavelength-autd3capi"><a class="header" href="#autdgetwavelength-autd3capi">AUTDGetWavelength (autd3capi)</a></h2>
<p>Get wavelength.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>double</td><td>-</td><td>wavelength</td></tr>
</tbody></table>
<h2 id="autdgetattenuation-autd3capi"><a class="header" href="#autdgetattenuation-autd3capi">AUTDGetAttenuation (autd3capi)</a></h2>
<p>Get attenuation coefficient.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>double</td><td>-</td><td>attenuation coefficient</td></tr>
</tbody></table>
<h2 id="autdsetwavelength-autd3capi"><a class="header" href="#autdsetwavelength-autd3capi">AUTDSetWavelength (autd3capi)</a></h2>
<p>Set wavelength.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>wavelength</td><td>double</td><td>in</td><td>wavelength</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsetattenuation-autd3capi"><a class="header" href="#autdsetattenuation-autd3capi">AUTDSetAttenuation (autd3capi)</a></h2>
<p>Set attenuation coefficient.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>attenuation</td><td>double</td><td>in</td><td>attenuation coefficient</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgetfpgainfo-autd3capi"><a class="header" href="#autdgetfpgainfo-autd3capi">AUTDGetFPGAInfo (autd3capi)</a></h2>
<p>Get the information of FPGAs.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.
The memory pointed by the <code>out</code> pointer should be the same length as the connected device.
In the FPGAs information, the lowest one bit indicates whether the fan is running or not,
The other bits are all 0.</p>
<p>Before calling this function, you need to set the read FPGA info
flag must be set to on.</p>
<p>This function returns false if it fails.
If it returns false, you can get the error message with <code>AUTDGetLastError</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>out</td><td>uint8_t *</td><td>out</td><td>FPGA informations</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if success</td></tr>
</tbody></table>
<h2 id="autdupdatectrlflags-autd3capi"><a class="header" href="#autdupdatectrlflags-autd3capi">AUTDUpdateCtrlFlags (autd3capi)</a></h2>
<p>Update control flags. One of the send functions.
After setting output enable, silent mode, force
fan, and reads FPGA info flags, these changes will be actually updated in the devices.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdsetdelayoffset-autd3capi"><a class="header" href="#autdsetdelayoffset-autd3capi">AUTDSetDelayOffset (autd3capi)</a></h2>
<p>Set output delays and duty offsets. 
One of the send functions.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>. delay,
The <code>delay</code> and <code>offset</code> must be a pointer to data of length (number of devices) <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">2</span><span class="mord">4</span><span class="mord">9</span></span></span></span> or nullptr.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>delay</td><td>uint8_t *</td><td>in</td><td>pointer to output delay data</td></tr>
<tr><td>offset</td><td>uint8_t *</td><td>in</td><td>pointer to duty offset data</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdgetlasterror-autd3capi"><a class="header" href="#autdgetlasterror-autd3capi">AUTDGetLastError (autd3capi)</a></h2>
<p>Get the error message that occurred last.</p>
<p>The error message is copied to <code>error</code> pointer. 
If the argument is nullptr, the error message is not copied. 
The function returns the length of the error message with null-terminated.</p>
<p>Since the length of the error message is variable, you should reserve a sufficiently large area, or, pass nullptr as <code>error</code> to get the required size and call it again.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>error</td><td>char*</td><td>out</td><td>pointer to error message</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>length of error message including null terminator</td></tr>
</tbody></table>
<h2 id="autdnumdevices-autd3capi"><a class="header" href="#autdnumdevices-autd3capi">AUTDNumDevices (autd3capi)</a></h2>
<p>Get the number of devices connected.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>number of devices</td></tr>
</tbody></table>
<h2 id="autdtransposition-autd3capi"><a class="header" href="#autdtransposition-autd3capi">AUTDTransPosition (autd3capi)</a></h2>
<p>Get the position of transducer specified by the device index and local transducer index.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>device_idx</td><td>int32_t</td><td>in</td><td>device index</td></tr>
<tr><td>local_trans_idx</td><td>int32_t</td><td>in</td><td>local transducer index</td></tr>
<tr><td>x</td><td>double*</td><td>out</td><td>x coordinate of transducer position</td></tr>
<tr><td>y</td><td>double*</td><td>out</td><td>y coordinate of transducer position</td></tr>
<tr><td>z</td><td>double*</td><td>out</td><td>z coordinate of transducer position</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autddevicexdirection-autd3capi"><a class="header" href="#autddevicexdirection-autd3capi">AUTDDeviceXDirection (autd3capi)</a></h2>
<p>Get the x direction of device specified by the device index.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>device_idx</td><td>int32_t</td><td>in</td><td>device index</td></tr>
<tr><td>x</td><td>double*</td><td>out</td><td>x coordinate of device x-direction</td></tr>
<tr><td>y</td><td>double*</td><td>out</td><td>y coordinate of device x-direction</td></tr>
<tr><td>z</td><td>double*</td><td>out</td><td>z coordinate of device x-direction</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autddeviceydirection-autd3capi"><a class="header" href="#autddeviceydirection-autd3capi">AUTDDeviceYDirection (autd3capi)</a></h2>
<p>Get the y direction of device specified by the device index.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>device_idx</td><td>int32_t</td><td>in</td><td>device index</td></tr>
<tr><td>x</td><td>double*</td><td>out</td><td>x coordinate of device y-direction</td></tr>
<tr><td>y</td><td>double*</td><td>out</td><td>y coordinate of device y-direction</td></tr>
<tr><td>z</td><td>double*</td><td>out</td><td>z coordinate of device y-direction</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autddevicezdirection-autd3capi"><a class="header" href="#autddevicezdirection-autd3capi">AUTDDeviceZDirection (autd3capi)</a></h2>
<p>Get the z direction of device specified by the device index.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>device_idx</td><td>int32_t</td><td>in</td><td>device index</td></tr>
<tr><td>x</td><td>double*</td><td>out</td><td>x coordinate of device z-direction</td></tr>
<tr><td>y</td><td>double*</td><td>out</td><td>y coordinate of device z-direction</td></tr>
<tr><td>z</td><td>double*</td><td>out</td><td>z coordinate of device z-direction</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgetfirmwareinfolistpointer-autd3capi"><a class="header" href="#autdgetfirmwareinfolistpointer-autd3capi">AUTDGetFirmwareInfoListPointer (autd3capi)</a></h2>
<p>Get a pointer to the Firmware information list.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.
The list created by this function should be released with <code>AUTDFreeFirmwareInfoListPointer</code> at the end.</p>
<p>The actual firmware information is retrieved with <code>AUTDGetFirmwareInfo</code>.</p>
<p>This function returns a value less than 0 if an error occurred.
You can get the error message with <code>AUTDGetLastError</code> if an error occurs.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to pointer to Firmware information list</td></tr>
</tbody></table>
<h2 id="autdgetfirmwareinfo-autd3capi"><a class="header" href="#autdgetfirmwareinfo-autd3capi">AUTDGetFirmwareInfo (autd3capi)</a></h2>
<p>Get firmware information.
Use <code>p_firm_info_list</code> created by <code>AUTDGetFirmwareInfoListPointer</code>.</p>
<p><code>cpu_ver</code> and <code>fpga_ver</code> should be a pointer to a buffer, where the length of 128 is enough.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>p_firm_info_list</td><td>void*</td><td>in</td><td>pointer to Firmware information list</td></tr>
<tr><td>index</td><td>int32_t</td><td>in</td><td>Firmware information index</td></tr>
<tr><td>cpu_ver</td><td>char*</td><td>out</td><td>pointer to CPU version string</td></tr>
<tr><td>fpga_ver</td><td>char*</td><td>out</td><td>pointer to FPGA version string</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdfreefirmwareinfolistpointer-autd3capi"><a class="header" href="#autdfreefirmwareinfolistpointer-autd3capi">AUTDFreeFirmwareInfoListPointer (autd3capi)</a></h2>
<p>Release the firmware information list obtained with <code>AUTDGetFirmwareInfoListPointer</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>p_firm_info_list</td><td>void*</td><td>in</td><td>pointer to Firmware information list</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainnull-autd3capi"><a class="header" href="#autdgainnull-autd3capi">AUTDGainNull (autd3capi)</a></h2>
<p>Create Gain::Null.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgaingrouped-autd3capi"><a class="header" href="#autdgaingrouped-autd3capi">AUTDGainGrouped (autd3capi)</a></h2>
<p>Create Gain::Grouped.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgaingroupedadd-autd3capi"><a class="header" href="#autdgaingroupedadd-autd3capi">AUTDGainGroupedAdd (autd3capi)</a></h2>
<p>Add a Gain to Gain::Grouped.
<code>grouped_gain</code> is the Gain created by <code>AUTDGainGrouped</code>. </p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>grouped_gain</td><td>void*</td><td>in</td><td>pointer to Grouped Gain</td></tr>
<tr><td>device_id</td><td>int32_t</td><td>in</td><td>Device Id</td></tr>
<tr><td>gain</td><td>void*</td><td>in</td><td>GainPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainfocalpoint-autd3capi"><a class="header" href="#autdgainfocalpoint-autd3capi">AUTDGainFocalPoint (autd3capi)</a></h2>
<p>Create Gain::FocalPoint.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>x</td><td>double</td><td>in</td><td>x coordinate of focal point</td></tr>
<tr><td>y</td><td>double</td><td>in</td><td>y coordinate of focal point</td></tr>
<tr><td>z</td><td>double</td><td>in</td><td>z coordinate of focal point</td></tr>
<tr><td>duty</td><td>uint8_t</td><td>in</td><td>duty ratio of Gain</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainbesselbeam-autd3capi"><a class="header" href="#autdgainbesselbeam-autd3capi">AUTDGainBesselBeam (autd3capi)</a></h2>
<p>Create Gain::Bessel.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>x</td><td>double</td><td>in</td><td>x coordinate of apex</td></tr>
<tr><td>y</td><td>double</td><td>in</td><td>y coordinate of apex</td></tr>
<tr><td>z</td><td>double</td><td>in</td><td>z coordinate of apex</td></tr>
<tr><td>n_x</td><td>double</td><td>in</td><td>x coordinate of direction</td></tr>
<tr><td>n_y</td><td>double</td><td>in</td><td>y coordinate of direction</td></tr>
<tr><td>n_z</td><td>double</td><td>in</td><td>z coordinate of direction</td></tr>
<tr><td>theta_z</td><td>double</td><td>in</td><td>angle between the side of the cone and the plane perpendicular to direction of the beam</td></tr>
<tr><td>duty</td><td>uint8_t</td><td>in</td><td>duty ratio of Gain</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainplanewave-autd3capi"><a class="header" href="#autdgainplanewave-autd3capi">AUTDGainPlaneWave (autd3capi)</a></h2>
<p>Create Gain::PlaneWave.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>n_x</td><td>double</td><td>in</td><td>x coordinate of direction</td></tr>
<tr><td>n_y</td><td>double</td><td>in</td><td>y coordinate of direction</td></tr>
<tr><td>n_z</td><td>double</td><td>in</td><td>z coordinate of direction</td></tr>
<tr><td>duty</td><td>uint8_t</td><td>in</td><td>duty ratio of Gain</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgaincustom-autd3capi"><a class="header" href="#autdgaincustom-autd3capi">AUTDGainCustom (autd3capi)</a></h2>
<p>Create Gain::Custom.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>data</td><td>uint16_t*</td><td>in</td><td>pointer to data</td></tr>
<tr><td>data_length</td><td>int32_t</td><td>in</td><td>length of data</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgaintransducertest-autd3capi"><a class="header" href="#autdgaintransducertest-autd3capi">AUTDGainTransducerTest (autd3capi)</a></h2>
<p>Create Gain::TransducerTest.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>idx</td><td>int32_t</td><td>in</td><td>global index of transducer</td></tr>
<tr><td>duty</td><td>uint8_t</td><td>in</td><td>duty ratio</td></tr>
<tr><td>phase</td><td>uint8_t</td><td>in</td><td>phase</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autddeletegain-autd3capi"><a class="header" href="#autddeletegain-autd3capi">AUTDDeleteGain (autd3capi)</a></h2>
<p>Delete the Gain you created.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void*</td><td>in</td><td>GainPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationstatic-autd3capi"><a class="header" href="#autdmodulationstatic-autd3capi">AUTDModulationStatic (autd3capi)</a></h2>
<p>Create Modulation::Static.</p>
<p>You should delete the modulation you created with <code>AUTDDeleteModulation</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void**</td><td>out</td><td>ModulationPtr</td></tr>
<tr><td>duty</td><td>uint8_t</td><td>in</td><td>duty ratio</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationcustom-autd3capi"><a class="header" href="#autdmodulationcustom-autd3capi">AUTDModulationCustom (autd3capi)</a></h2>
<p>Create Modulation::Custom.</p>
<p>You should delete the modulation you created with <code>AUTDDeleteModulation</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void**</td><td>out</td><td>ModulationPtr</td></tr>
<tr><td>buf</td><td>uint8_t*</td><td>in</td><td>ModulationPtr buffer</td></tr>
<tr><td>size</td><td>uint32_t</td><td>in</td><td>length to modulation buffer</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationsine-autd3capi"><a class="header" href="#autdmodulationsine-autd3capi">AUTDModulationSine (autd3capi)</a></h2>
<p>Create Modulation::Sine.</p>
<p>You should delete the modulation you created with <code>AUTDDeleteModulation</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void**</td><td>out</td><td>ModulationPtr</td></tr>
<tr><td>freq</td><td>int32_t</td><td>in</td><td>frequency</td></tr>
<tr><td>amplitude</td><td>double</td><td>in</td><td>amplitude of sin wave</td></tr>
<tr><td>offset</td><td>double</td><td>in</td><td>offset of sin wave</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationsinepressure-autd3capi"><a class="header" href="#autdmodulationsinepressure-autd3capi">AUTDModulationSinePressure (autd3capi)</a></h2>
<p>Create Modulation::SinePressure.</p>
<p>You should delete the modulation you created with <code>AUTDDeleteModulation</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void**</td><td>out</td><td>ModulationPtr</td></tr>
<tr><td>freq</td><td>int32_t</td><td>in</td><td>frequency</td></tr>
<tr><td>amplitude</td><td>double</td><td>in</td><td>amplitude of sin wave</td></tr>
<tr><td>offset</td><td>double</td><td>in</td><td>offset of sin wave</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationsinelegacy-autd3capi"><a class="header" href="#autdmodulationsinelegacy-autd3capi">AUTDModulationSineLegacy (autd3capi)</a></h2>
<p>Create Modulation::SineLegacy.</p>
<p>You should delete the modulation you created with <code>AUTDDeleteModulation</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void**</td><td>out</td><td>ModulationPtr</td></tr>
<tr><td>freq</td><td>double</td><td>in</td><td>frequency</td></tr>
<tr><td>amplitude</td><td>double</td><td>in</td><td>amplitude of sin wave</td></tr>
<tr><td>offset</td><td>double</td><td>in</td><td>offset of sin wave</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationsquare-autd3capi"><a class="header" href="#autdmodulationsquare-autd3capi">AUTDModulationSquare (autd3capi)</a></h2>
<p>Create Modulation::Square.</p>
<p>You should delete the modulation you created with <code>AUTDDeleteModulation</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void**</td><td>out</td><td>ModulationPtr</td></tr>
<tr><td>freq</td><td>int32_t</td><td>in</td><td>frequency</td></tr>
<tr><td>low</td><td>uint8_t</td><td>in</td><td>duty ratio at low level</td></tr>
<tr><td>high</td><td>uint8_t</td><td>in</td><td>duty ratio at high level</td></tr>
<tr><td>duty</td><td>double</td><td>in</td><td>duty ratio of the square wave, i.e., ratio of duration of high level to period</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationsamplingfreqdiv-autd3capi"><a class="header" href="#autdmodulationsamplingfreqdiv-autd3capi">AUTDModulationSamplingFreqDiv (autd3capi)</a></h2>
<p>Get sampling frequency division ratio of Modulation.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void*</td><td>in</td><td>ModulationPtr</td></tr>
<tr><td>return</td><td>uint32_t</td><td>-</td><td>sampling frequency division ratio</td></tr>
</tbody></table>
<h2 id="autdmodulationsetsamplingfreqdiv-autd3capi"><a class="header" href="#autdmodulationsetsamplingfreqdiv-autd3capi">AUTDModulationSetSamplingFreqDiv (autd3capi)</a></h2>
<p>Set sampling frequency division ratio of Modulation.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void*</td><td>in</td><td>ModulationPtr</td></tr>
<tr><td>freq_div</td><td>uint32_t</td><td>in</td><td>sampling frequency division ratio</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationsamplingfreq-autd3capi"><a class="header" href="#autdmodulationsamplingfreq-autd3capi">AUTDModulationSamplingFreq (autd3capi)</a></h2>
<p>Get sampling frequency of Modulation.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void*</td><td>in</td><td>ModulationPtr</td></tr>
<tr><td>return</td><td>double</td><td>-</td><td>sampling frequency</td></tr>
</tbody></table>
<h2 id="autddeletemodulation-autd3capi"><a class="header" href="#autddeletemodulation-autd3capi">AUTDDeleteModulation (autd3capi)</a></h2>
<p>Delete the Modulation you created.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void*</td><td>in</td><td>ModulationPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsequence-autd3capi"><a class="header" href="#autdsequence-autd3capi">AUTDSequence (autd3capi)</a></h2>
<p>Create PointSequence.
You have to delete the created PointSequence with <code>AUTDDeleteSequence</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to PointSequencePtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainsequence-autd3capi"><a class="header" href="#autdgainsequence-autd3capi">AUTDGainSequence (autd3capi)</a></h2>
<p>Create GainSequence.
The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>You have to delete the created GainSequence with <code>AUTDDeleteSequence</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to GainSequencePtr</td></tr>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>gain_mode</td><td>uint16_t</td><td>in</td><td>gain mode of GainSequence</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsequenceaddpoint-autd3capi"><a class="header" href="#autdsequenceaddpoint-autd3capi">AUTDSequenceAddPoint (autd3capi)</a></h2>
<p>Add control point to PointSequence.</p>
<p><code>seq</code> is a PointSequence created with <code>AUTDSequence</code>.</p>
<p>This function returns false if it fails.
If it returns false, you can get the error message with <code>AUTDGetLastError</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>GainSequencePtr</td></tr>
<tr><td>x</td><td>double</td><td>in</td><td>x coordinate of point</td></tr>
<tr><td>y</td><td>double</td><td>in</td><td>y coordinate of point</td></tr>
<tr><td>z</td><td>double</td><td>in</td><td>z coordinate of point</td></tr>
<tr><td>duty</td><td>uint8_t</td><td>in</td><td>duty ratio of point</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if success</td></tr>
</tbody></table>
<h2 id="autdsequenceaddgain-autd3capi"><a class="header" href="#autdsequenceaddgain-autd3capi">AUTDSequenceAddGain (autd3capi)</a></h2>
<p>Add Gain to GainSequence.</p>
<p><code>seq</code> is a GainSequence created with <code>AUTDGainSequence</code>.</p>
<p>This function returns false if it fails.
If it returns false, you can get the error message with <code>AUTDGetLastError</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>GainSequencePtr</td></tr>
<tr><td>gain</td><td>void*</td><td>in</td><td>GainPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if success</td></tr>
</tbody></table>
<h2 id="autdsequencesetfreq-autd3capi"><a class="header" href="#autdsequencesetfreq-autd3capi">AUTDSequenceSetFreq (autd3capi)</a></h2>
<p>Set frequency of Sequence.</p>
<p><code>seq</code> is a PointSequence created with <code>AUTDSequence</code> or a GainSequence created with <code>AUTDGainSequence</code>.</p>
<p>This function returns actual frequency.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>SequencePtr</td></tr>
<tr><td>freq</td><td>double</td><td>in</td><td>frequency</td></tr>
<tr><td>return</td><td>double</td><td>-</td><td>actual frequency</td></tr>
</tbody></table>
<h2 id="autdsequencefreq-autd3capi"><a class="header" href="#autdsequencefreq-autd3capi">AUTDSequenceFreq (autd3capi)</a></h2>
<p>Get frequency of Sequence.</p>
<p><code>seq</code> is a PointSequence created with <code>AUTDSequence</code> or a GainSequence created with <code>AUTDGainSequence</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>SequencePtr</td></tr>
<tr><td>return</td><td>double</td><td>-</td><td>actual frequency</td></tr>
</tbody></table>
<h2 id="autdsequenceperiod-autd3capi"><a class="header" href="#autdsequenceperiod-autd3capi">AUTDSequencePeriod (autd3capi)</a></h2>
<p>Get cycle of Sequence in unit of μs.</p>
<p><code>seq</code> is a PointSequence created with <code>AUTDSequence</code> or a GainSequence created with <code>AUTDGainSequence</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>SequencePtr</td></tr>
<tr><td>return</td><td>uint32_t</td><td>-</td><td>period in μs</td></tr>
</tbody></table>
<h2 id="autdsequencesamplingperiod-autd3capi"><a class="header" href="#autdsequencesamplingperiod-autd3capi">AUTDSequenceSamplingPeriod (autd3capi)</a></h2>
<p>Get sampling cycle of Sequence in unit of μs.</p>
<p><code>seq</code> is a PointSequence created with <code>AUTDSequence</code> or a GainSequence created with <code>AUTDGainSequence</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>SequencePtr</td></tr>
<tr><td>return</td><td>uint32_t</td><td>-</td><td>sampling period in μs</td></tr>
</tbody></table>
<h2 id="autdsequencesamplingfreq-autd3capi"><a class="header" href="#autdsequencesamplingfreq-autd3capi">AUTDSequenceSamplingFreq (autd3capi)</a></h2>
<p>Get sampling frequency of Sequence.</p>
<p><code>seq</code> is a PointSequence created with <code>AUTDSequence</code> or a GainSequence created with <code>AUTDGainSequence</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>SequencePtr</td></tr>
<tr><td>return</td><td>double</td><td>-</td><td>sampling freqyency</td></tr>
</tbody></table>
<h2 id="autdsequencesamplingfreqdiv-autd3capi"><a class="header" href="#autdsequencesamplingfreqdiv-autd3capi">AUTDSequenceSamplingFreqDiv (autd3capi)</a></h2>
<p>Get sampling frequency division ratio of Sequence.</p>
<p><code>seq</code> is a PointSequence created with <code>AUTDSequence</code> or a GainSequence created with <code>AUTDGainSequence</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>SequencePtr</td></tr>
<tr><td>return</td><td>uint32_t</td><td>-</td><td>sampling freqyency division ratio</td></tr>
</tbody></table>
<h2 id="autdsequencesetsamplingfreqdiv-autd3capi"><a class="header" href="#autdsequencesetsamplingfreqdiv-autd3capi">AUTDSequenceSetSamplingFreqDiv (autd3capi)</a></h2>
<p>Set sampling frequency division ratio of Sequence.</p>
<p><code>seq</code> is a PointSequence created with <code>AUTDSequence</code> or a GainSequence created with <code>AUTDGainSequence</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>SequencePtr</td></tr>
<tr><td>freq_div</td><td>uint32_t</td><td>in</td><td>sampling freqyency division ratio</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autddeletesequence-autd3capi"><a class="header" href="#autddeletesequence-autd3capi">AUTDDeleteSequence (autd3capi)</a></h2>
<p>Delete Sequence you created.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>seq</td><td>void*</td><td>in</td><td>SequencePtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdstop-autd3capi"><a class="header" href="#autdstop-autd3capi">AUTDStop (autd3capi)</a></h2>
<p>Stop outputting.
One of the send functions.</p>
<p>The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdpause-autd3capi"><a class="header" href="#autdpause-autd3capi">AUTDPause (autd3capi)</a></h2>
<p>Pause outputting.
One of the send functions. 
The output can be resumed with <code>AUTDResume</code>.</p>
<p>The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdresume-autd3capi"><a class="header" href="#autdresume-autd3capi">AUTDResume (autd3capi)</a></h2>
<p>Resume outputting.
One of the send functions.</p>
<p>The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdsendheader-autd3capi"><a class="header" href="#autdsendheader-autd3capi">AUTDSendHeader (autd3capi)</a></h2>
<p>Send Header data (Modulation). 
One of the send functions.</p>
<p>The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>If <code>check_ack</code> is true, the function waits until the data is processed by the device.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>header</td><td>void*</td><td>in</td><td>pointer to Header</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdsendbody-autd3capi"><a class="header" href="#autdsendbody-autd3capi">AUTDSendBody (autd3capi)</a></h2>
<p>Send Body data (Gain, PointSequence, GainSequence). 
One of the send functions.</p>
<p>The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>If <code>check_ack</code> is true, the function waits until the data is processed by the device.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>body</td><td>void*</td><td>in</td><td>pointer to Body</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdsendheaderbody-autd3capi"><a class="header" href="#autdsendheaderbody-autd3capi">AUTDSendHeaderBody (autd3capi)</a></h2>
<p>Send Header (Modulation) and Body (Gain, PointSequence, GainSequence). 
One of the send functions.</p>
<p>The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>If <code>check_ack</code> is true, the function waits until the data is processed by the device.</p>
<p>This function returns a value less than 0 if an error occurred.
If an error occurs, you can get the error message with <code>AUTDGetLastError</code>.
Also, if the check ack flag is on and the return value is greater than 0, it guarantees that the data has been processed by the device.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>header</td><td>void*</td><td>in</td><td>pointer to Header</td></tr>
<tr><td>body</td><td>void*</td><td>in</td><td>pointer to Body</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, it guarantees devices have processed data. if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, error ocurred.</td></tr>
</tbody></table>
<h2 id="autdstmcontroller-autd3capi"><a class="header" href="#autdstmcontroller-autd3capi">AUTDSTMController (autd3capi)</a></h2>
<p>Get STMController from Controller.</p>
<p>The <code>handle</code> is the controller created by <code>AUTDCreateController</code>.</p>
<p>The use of handle is prohibited between the call to this function and the call to <code>AUTDFinishSTM</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to STMControllerPtr</td></tr>
<tr><td>handle</td><td>void*</td><td>out</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdaddstmgain-autd3capi"><a class="header" href="#autdaddstmgain-autd3capi">AUTDAddSTMGain (autd3capi)</a></h2>
<p>Add Gain to STMController.</p>
<p>The <code>handle</code> is the stm controller created by <code>AUTDSTMController</code>.</p>
<p>This function returns false if it fails.
If it returns false, you can get the error message with <code>AUTDGetLastError</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>STMControllerPtr</td></tr>
<tr><td>gain</td><td>void*</td><td>in</td><td>GainPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if success</td></tr>
</tbody></table>
<h2 id="autdstartstm-autd3capi"><a class="header" href="#autdstartstm-autd3capi">AUTDStartSTM (autd3capi)</a></h2>
<p>Start STM.</p>
<p>The <code>handle</code> is the stm controller created by <code>AUTDSTMController</code>.</p>
<p>This function returns false if it fails.
If it returns false, you can get the error message with <code>AUTDGetLastError</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>STMControllerPtr</td></tr>
<tr><td>freq</td><td>double</td><td>in</td><td>frequency</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if success</td></tr>
</tbody></table>
<h2 id="autdstopstm-autd3capi"><a class="header" href="#autdstopstm-autd3capi">AUTDStopSTM (autd3capi)</a></h2>
<p>Stop STM.</p>
<p>The <code>handle</code> is the stm controller created by <code>AUTDSTMController</code>.</p>
<p>This function returns false if it fails.
If it returns false, you can get the error message with <code>AUTDGetLastError</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>STMControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if success</td></tr>
</tbody></table>
<h2 id="autdfinishstm-autd3capi"><a class="header" href="#autdfinishstm-autd3capi">AUTDFinishSTM (autd3capi)</a></h2>
<p>Finish STM.</p>
<p>The <code>handle</code> is the stm controller created by <code>AUTDSTMController</code>.</p>
<p>This function returns false if it fails.
If it returns false, you can get the error message with <code>AUTDGetLastError</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>handle</td><td>void*</td><td>in</td><td>STMControllerPtr</td></tr>
<tr><td>return</td><td>bool</td><td>-</td><td>true if success</td></tr>
</tbody></table>
<h2 id="autdeigen3backend-autd3capi-holo-gain"><a class="header" href="#autdeigen3backend-autd3capi-holo-gain">AUTDEigen3Backend (autd3capi-holo-gain)</a></h2>
<p>Create Eigen Backend.</p>
<p>You should delete the created Backend with <code>AUTDDeleteBackend</code> in the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to BackendPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autddeletebackend-autd3capi-holo-gain"><a class="header" href="#autddeletebackend-autd3capi-holo-gain">AUTDDeleteBackend (autd3capi-holo-gain)</a></h2>
<p>Delete Backend.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainholosdp-autd3capi-holo-gain"><a class="header" href="#autdgainholosdp-autd3capi-holo-gain">AUTDGainHoloSDP (autd3capi-holo-gain)</a></h2>
<p>Create holo::SDP.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>alpha</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>repeat</td><td>uint64_t</td><td>in</td><td>parameter</td></tr>
<tr><td>normalize</td><td>bool</td><td>in</td><td>parameter</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainholoevd-autd3capi-holo-gain"><a class="header" href="#autdgainholoevd-autd3capi-holo-gain">AUTDGainHoloEVD (autd3capi-holo-gain)</a></h2>
<p>Create holo::EVD.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>gamma</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>normalize</td><td>bool</td><td>in</td><td>parameter</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainholonaive-autd3capi-holo-gain"><a class="header" href="#autdgainholonaive-autd3capi-holo-gain">AUTDGainHoloNaive (autd3capi-holo-gain)</a></h2>
<p>Create holo::Naive.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainhologs-autd3capi-holo-gain"><a class="header" href="#autdgainhologs-autd3capi-holo-gain">AUTDGainHoloGS (autd3capi-holo-gain)</a></h2>
<p>Create holo::GS.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>repeat</td><td>uint64_t</td><td>in</td><td>parameter</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainhologspat-autd3capi-holo-gain"><a class="header" href="#autdgainhologspat-autd3capi-holo-gain">AUTDGainHoloGSPAT (autd3capi-holo-gain)</a></h2>
<p>Create holo::GSPAT.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>repeat</td><td>uint64_t</td><td>in</td><td>parameter</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainhololm-autd3capi-holo-gain"><a class="header" href="#autdgainhololm-autd3capi-holo-gain">AUTDGainHoloLM (autd3capi-holo-gain)</a></h2>
<p>Create holo::LM.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>eps_1</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>eps_2</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>tau</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>k_max</td><td>uint64_t</td><td>in</td><td>parameter</td></tr>
<tr><td>initial</td><td>double*</td><td>in</td><td>parameter</td></tr>
<tr><td>initial_size</td><td>int32_t</td><td>in</td><td>length of initial</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainhologaussnewton-autd3capi-holo-gain"><a class="header" href="#autdgainhologaussnewton-autd3capi-holo-gain">AUTDGainHoloGaussNewton (autd3capi-holo-gain)</a></h2>
<p>Create holo::GaussNewton.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>eps_1</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>eps_2</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>k_max</td><td>uint64_t</td><td>in</td><td>parameter</td></tr>
<tr><td>initial</td><td>double*</td><td>in</td><td>parameter</td></tr>
<tr><td>initial_size</td><td>int32_t</td><td>in</td><td>length of initial</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainhologradientdescent-autd3capi-holo-gain"><a class="header" href="#autdgainhologradientdescent-autd3capi-holo-gain">AUTDGainHoloGradientDescent (autd3capi-holo-gain)</a></h2>
<p>Create holo::GradientDescent.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>eps</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>step</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>k_max</td><td>uint64_t</td><td>in</td><td>parameter</td></tr>
<tr><td>initial</td><td>double*</td><td>in</td><td>parameter</td></tr>
<tr><td>initial_size</td><td>int32_t</td><td>in</td><td>length of initial</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainholoapo-autd3capi-holo-gain"><a class="header" href="#autdgainholoapo-autd3capi-holo-gain">AUTDGainHoloAPO (autd3capi-holo-gain)</a></h2>
<p>Create holo::APO.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>eps</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>lambda</td><td>double</td><td>in</td><td>parameter</td></tr>
<tr><td>k_max</td><td>uint64_t</td><td>in</td><td>parameter</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgainhologreedy-autd3capi-holo-gain"><a class="header" href="#autdgainhologreedy-autd3capi-holo-gain">AUTDGainHoloGreedy (autd3capi-holo-gain)</a></h2>
<p>Create holo::Greedy.</p>
<p><code>points</code> is a pointer to an array of length <code>size</code> <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span></span></span></span>, where the focal points are stored in the following order: x[0], y[0], z[0], x[1], …
<code>amps</code> is a pointer to an array of length <code>size</code> and specifies the intensity of foci.</p>
<p>You must delete the created Gain with <code>AUTDDeleteGain</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>gain</td><td>void**</td><td>out</td><td>pointer to GainPtr</td></tr>
<tr><td>backend</td><td>void*</td><td>in</td><td>BackendPtr</td></tr>
<tr><td>points</td><td>double*</td><td>in</td><td>pointer to foci array</td></tr>
<tr><td>amps</td><td>double*</td><td>in</td><td>pointer to amplitudes array</td></tr>
<tr><td>size</td><td>int32_t</td><td>in</td><td>number of foci</td></tr>
<tr><td>phase_div</td><td>int32_t</td><td>in</td><td>parameter</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationrawpcm-autd3capi-from-file-modulation"><a class="header" href="#autdmodulationrawpcm-autd3capi-from-file-modulation">AUTDModulationRawPCM (autd3capi-from-file-modulation)</a></h2>
<p>Create modulation::RawPCM.</p>
<p>You should delete the modulation you created with <code>AUTDDeleteModulation</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void**</td><td>out</td><td>pointer to ModulationPtr</td></tr>
<tr><td>filename</td><td>char*</td><td>in</td><td>pointer to filename string</td></tr>
<tr><td>sampling_freq</td><td>double</td><td>in</td><td>sampling frequency of PCM</td></tr>
<tr><td>mod_sampling_freq_div</td><td>uint16_t</td><td>in</td><td>Sampling frequency division</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdmodulationwav-autd3capi-from-file-modulation"><a class="header" href="#autdmodulationwav-autd3capi-from-file-modulation">AUTDModulationWav (autd3capi-from-file-modulation)</a></h2>
<p>Create modulation::Wav.</p>
<p>You should delete the modulation you created with <code>AUTDDeleteModulation</code> at the end.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>mod</td><td>void**</td><td>out</td><td>pointer to ModulationPtr</td></tr>
<tr><td>filename</td><td>char*</td><td>in</td><td>pointer to filename string</td></tr>
<tr><td>mod_sampling_freq_div</td><td>uint16_t</td><td>in</td><td>Sampling frequency division</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdlinktwincat-autd3capi-twincat-link"><a class="header" href="#autdlinktwincat-autd3capi-twincat-link">AUTDLinkTwinCAT (autd3capi-twincat-link)</a></h2>
<p>Create link::TwinCAT.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to LinkPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdlinkremotetwincat-autd3capi-remote-twincat-link"><a class="header" href="#autdlinkremotetwincat-autd3capi-remote-twincat-link">AUTDLinkRemoteTwinCAT (autd3capi-remote-twincat-link)</a></h2>
<p>Create link::RemoteTwinCAT.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to LinkPtr</td></tr>
<tr><td>remote_ip_addr</td><td>char*</td><td>in</td><td>pointer to remote ip address</td></tr>
<tr><td>remote_ams_net_id</td><td>char*</td><td>in</td><td>pointer to remote ams net id</td></tr>
<tr><td>local_ams_net_id</td><td>char*</td><td>in</td><td>pointer to local ams net id</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdgetadapterpointer-autd3capi-soem-link"><a class="header" href="#autdgetadapterpointer-autd3capi-soem-link">AUTDGetAdapterPointer (autd3capi-soem-link)</a></h2>
<p>Get a pointer to the EtherCAT adapter information list.</p>
<p>Get the EtherCAT adapter information with <code>AUTDGetAdapter</code>.</p>
<p>The retrieved pointer has to be finally released with <code>AUTDFreeAdapterPointer</code>.</p>
<p>This function returns the size of the retrieved list.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to pointer to adapter information list</td></tr>
<tr><td>return</td><td>int32_t</td><td>-</td><td>length of EtherCAT adapter information list</td></tr>
</tbody></table>
<h2 id="autdgetadapter-autd3capi-soem-link"><a class="header" href="#autdgetadapter-autd3capi-soem-link">AUTDGetAdapter (autd3capi-soem-link)</a></h2>
<p>Get EtherCAT adapter information.</p>
<p><code>p_adapter</code> is a pointer created by <code>AUTDGetAdapterPointer</code>.</p>
<p><code>desc</code> and <code>name</code> are pointers to a buffer, where the length of 128 is sufficient.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>p_adapter</td><td>void*</td><td>in</td><td>pointer to EtherCAT adapter information list</td></tr>
<tr><td>index</td><td>int32_t</td><td>in</td><td>adapter index</td></tr>
<tr><td>desc</td><td>char*</td><td>in</td><td>adapter description</td></tr>
<tr><td>name</td><td>char*</td><td>in</td><td>adapter name</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdfreeadapterpointer-autd3capi-soem-link"><a class="header" href="#autdfreeadapterpointer-autd3capi-soem-link">AUTDFreeAdapterPointer (autd3capi-soem-link)</a></h2>
<p>Release pointer created by <code>AUTDGetAdapterPointer</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>p_adapter</td><td>void*</td><td>in</td><td>pointer to EtherCAT adapter information list</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdlinksoem-autd3capi-soem-link"><a class="header" href="#autdlinksoem-autd3capi-soem-link">AUTDLinkSOEM (autd3capi-soem-link)</a></h2>
<p>Create link::SOEM.</p>
<p><code>ifname</code> is a interface name, which can be obtained by <code>AUTDGetAdapter</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to LinkPtr</td></tr>
<tr><td>ifname</td><td>int32_t</td><td>in</td><td>number of devices</td></tr>
<tr><td>cycle_ticks</td><td>uint32_t</td><td>in</td><td>cycle ticks</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdsetsoemonlost-autd3capi-soem-link"><a class="header" href="#autdsetsoemonlost-autd3capi-soem-link">AUTDSetSOEMOnLost (autd3capi-soem-link)</a></h2>
<p>Set OnLostCallback to SOEM link.</p>
<p><code>link</code> is a link created by <code>AUTDLinkSOEM</code>.</p>
<p><code>ErrorHandler</code> is defined as <code>void (*)(const char*)</code>, and handler will be called with error message when error occurred.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>link</td><td>void*</td><td>in</td><td>SOEM LinkPtr</td></tr>
<tr><td>handler</td><td>ErrorHandler</td><td>in</td><td>error handler</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<h2 id="autdlinkemulator-autd3capi-emulator-link"><a class="header" href="#autdlinkemulator-autd3capi-emulator-link">AUTDLinkEmulator (autd3capi-emulator-link)</a></h2>
<p>Create link::Emulator.</p>
<p><code>cnt</code> is a controller created by <code>AUTDCreateController</code>.</p>
<table><thead><tr><th>Argument name / return</th><th>type</th><th>in/out</th><th>description</th></tr></thead><tbody>
<tr><td>out</td><td>void**</td><td>out</td><td>pointer to LinkPtr</td></tr>
<tr><td>port</td><td>uint16_t</td><td>in</td><td>number of devices</td></tr>
<tr><td>cnt</td><td>void*</td><td>in</td><td>ControllerPtr</td></tr>
<tr><td>return</td><td>void</td><td>-</td><td>nothing</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="emulator-1"><a class="header" href="#emulator-1">Emulator</a></h1>
<p><a href="https://github.com/shinolab/autd-emulator">autd-emulator</a> is a cross-platform emulator of AUTD3.</p>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<p>You can download the pre-compiled binary distributed on <a href="https://github.com/shinolab/autd-emulator/releases">GitHub</a> only for Windows 10 64bit.</p>
<p>For other OS, you have to install the rust compiler and compile it by yourself.</p>
<pre><code>git clone https://github.com/shinolab/autd-emulator.git
cd autd-emulator
cargo run --release
</code></pre>
<h2 id="how-to"><a class="header" href="#how-to">How to</a></h2>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/emu-home.jpg"/>
  <figcaption>Emulator</figcaption>
</figure>
<p>When you launch autd-emulator, you will see the screen as shown above figure.
In this state, when you execute a client program using the Emulator link, the sound field corresponding to the content of the client program is displayed.
The black panel in the center of the figure is called “Slice”, and you can visualize the sound field at any position by using this Slice.
The phase of the transducer is represented by the <em>hue</em> and the amplitude by the <em>intensity</em>.</p>
<p>The sound field displayed by the emulator is a simple superposition of spherical waves, and it does not take into account the directivitiy and nonlinear effects.</p>
<p>The GUI on the left side of the screen can be used to control the slice and the camera.
The GUI is based on <a href="https://github.com/ocornut/imgui">Dear ImGui</a>, which can be operated by mouse or by “Ctrl+click” to enter values by a keyboard.</p>
<p>You can also move the camera by “dragging” and rotate the camera by “Shift+dragging”.</p>
<h3 id="slice-tab"><a class="header" href="#slice-tab">Slice tab</a></h3>
<p>In the Slice tab, you can change the size, position, and rotation of the slice.
Rotation is specified by XYZ euler angles.
Clicking “xy”, “yz”, or “zx” button rotates the slice to the parallel state to each plane.</p>
<p>The intensity of the sound pressure is represented by color in Slice.
“Color scale” represents the maximum value of sound pressure in this color space.
If you use a large number of devices, the color may be saturated, in which case you should increase the value of “Color scale”.
You can also specify the alpha value of Slice itself by `Slice alpha’.</p>
<h3 id="camera-tab"><a class="header" href="#camera-tab">Camera tab</a></h3>
<p>In Camera tab, you can change camera position, rotation, field of view angle, near clip and far clip settings.
Rotation is specified by XYZ euler angle.</p>
<h3 id="config-tab"><a class="header" href="#config-tab">Config tab</a></h3>
<p>In the Config tab, you can set the wavelength, the alpha value of the transducers, and the background color.</p>
<p>In addition, after connecting to the Emulator link, you can switch the display/enable for each device.
When the display is turned off, the device is not displayed but contributes to the sound field.
If you turn off the enable, it does not contribute to the sound field.
In addition, the axis of each device can be displayed.</p>
<h3 id="info-tab"><a class="header" href="#info-tab">Info tab</a></h3>
<p>In the Info tab, you can check the information of Modulation and Sequence.</p>
<p>Modulation is not displayed on the Slice.
Instead, how the sound pressure is modulated is shown in this tab.
In raw mode, you can see how the duty ratio is modulated.</p>
<p>When a Sequence is sent, the information of the Sequence is displayed.
Sequence does not switch automatically, instead, you can use the “sequence index” to display the corresponding Sequence.</p>
<p>In the flag section, the Control flag is displayed.
Even if Silent mode is turned on, there is no change in the display on Slice.
Also, Output delay and Duty offset are ignored.</p>
<h3 id="log-tab"><a class="header" href="#log-tab">Log tab</a></h3>
<p>In the Log tab, you can see the log for debugging.</p>
<h3 id="other-settings"><a class="header" href="#other-settings">Other settings</a></h3>
<p>All settings are stored in <code>settings.json</code>.
Some settings can be edited only from <code>settings.json</code>.
The most important ones are “port” and “vsync”.
“port” is the port number used to connect to the SDK’s Emulator link.
If you set “vsync” to true, vertical synchronization is enabled.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="gui"><a class="header" href="#gui">GUI</a></h1>
<figure>
  <img src="https://raw.githubusercontent.com/shinolab/autd3-library-software/master/book/src/fig/Users_Manual/GUI.jpg"/>
  <figcaption>GUI controller</figcaption>
</figure>
<p><a href="https://github.com/shinolab/AUTD3-GUI-Controller">AUTD3 GUI Controller</a> is a program to operate AUTD with GUI.
It is made by using C# and WPF, and currently, it works only on Windows.</p>
<h2 id="install-2"><a class="header" href="#install-2">Install</a></h2>
<p>There is a pre-compiled binary on GitHub, so please download it.</p>
<h2 id="how-to-1"><a class="header" href="#how-to-1">How to</a></h2>
<p>After starting the AUTD3 GUI Controller, the Home screen will be displayed as shown above.
You can configure various settings from the tabs on the left.</p>
<h3 id="geometry-1"><a class="header" href="#geometry-1">Geometry</a></h3>
<p>In Geometry tab, you can define Geometry.
Click “+” button to add a device and specify its position and rotation.
Currently, specifying rotation by quaternions is not supported.
Grouped Gain is not also supported, so you can’t specify the group ID.
The order can be changed by drag &amp; drop.</p>
<h3 id="link-1"><a class="header" href="#link-1">Link</a></h3>
<p>After defining the Geometry, select Link in the Link tab and click the Open button to connect.</p>
<h3 id="gain--modulation"><a class="header" href="#gain--modulation">Gain &amp; Modulation</a></h3>
<p>After connecting the Link, select Gain/Modulation in the Gain/Modulation tab, and send it to the device with the “+” button at the bottom right.</p>
<p>Grouped Gain is not supported.</p>
<h3 id="sequence-2"><a class="header" href="#sequence-2">Sequence</a></h3>
<p>Gain Sequence is not supported, and only PointSequence can be used.</p>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<p>The File button at the top of the screen saves the current settings.
You can recall the saved settings by clicking the folder button on the right.
You can also use the green triangle button on the right to resume, and the red pause button on the right to pause.</p>
<p>To exit, press the upper right button.
When you exit, the current settings will be automatically saved and loaded at the next startup.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="citation"><a class="header" href="#citation">Citation</a></h1>
<p>If you use this SDK in your research please consider to include the following citation in your publications:</p>
<ul>
<li><a href="https://ieeexplore.ieee.org/document/9392322">S. Suzuki, S. Inoue, M. Fujiwara, Y. Makino and H. Shinoda, “AUTD3: Scalable Airborne Ultrasound Tactile Display,” in IEEE Transactions on Haptics, doi: 10.1109/TOH.2021.3069976.</a></li>
<li>S. Inoue, Y. Makino and H. Shinoda “Scalable Architecture for Airborne Ultrasound Tactile Display”, Asia Haptics 2016</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
